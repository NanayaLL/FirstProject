





​               

# 1 day01

## 1.1 四个阶段回顾

**1，j2se：java基础、面向对象、集合与泛型、注解和反射、异常、io、socket、多线程**

**2，oracle：监听、实例、服务、表、视图、索引、存储函数、存储过程、序列、触发器、游标、包**

​    **ddl：数据库定义语言--》create, drop, alter**

​    **dcl：数据库控制语言--》commit, rollback ,savepoint, grant, revoke**

​    **dml：数据库管理语言-->insert, delete, update**

​    **dql：数据库查询语言  select**

​    **表连接、子查询、五大约束、单行函数、组函数、分页**

**3，前端：html , css, js, jquery, json, ajax, bootstrap, [easyui, jqgrid,datatable表格插件】，jquery-tmpl，ztree[dtree]，vue/angularjs/react[前端的mvc框架]，nodejs**

**4，jsp/servlet：servlet【三种实现方式、生命周期、单例多线程、url捕获】，jsp【三大指令、静态元素、注释、java片段、java表达式、java声明、动作、jstl、el、作用域pagecontext,request,session,application】、jsp9大内置对象、jsp8个监听器、el11个内置对象、文件上传下载、国际化、tomcat的配置和启动、mvc逻辑、代码分层、filter、乱码的解决**

## 1.2 简答题

**（1）java中的基本类型有哪些，什么是包装类，什么是装箱拆箱**

整数类型：byte   short      int    long

浮点型：double（双精度）   float（单精度）

布尔·型：boolean

字符型：char

怎么理解包装类：为了满足Java语言面向对象的这一特性，上述基本数据类型中的每一个在java.lang包中都有一个包装类，即将每个基本类型都包装成了一个类。常用的包装类可以分为三类

除了int——Integer  char——character 其他都是首字母大写即可

装箱：就是将基本数据类型封装成对象即包装类，例如int——转化成Integer对象

拆箱与之相反：将Integer对象转化成int基本数据类型。

**（2）开闭原则是什么，如何实现**

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

通俗来说就是：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。

A．抽象约束

\1.     第一，通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；

\2.     第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；

\3.     第三，抽象层尽量保持稳定，一旦确定即不允许修改。

·        B．元数据（metadata）控制模块行为

·        元数据就是用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。

·        Spring容器就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control）

·        C．制定项目章程

在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。

·        D．封装变化

·        第一，将相同的变化封装到一个接口或者抽象类中；

·        第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。

**（3）使用jquery如何定位一个元素**

**$(“#+id”) id**选择器，还有**html**选择器，还有**class**选择器，还有一些别的选择器

**（4）一个文件如何导入js，css文件**

**Js**：通过**scrapt src=“”**

**Link**：通过 **link href=“”** **来导入**

**（5）oracle5个约束**

1.—-主键约束（Primay Key Coustraint） 唯一性，非空性

 2.—-唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个

 3.—-检查约束 (Check Counstraint) 对该列数据的范围、格式的限制（如：年龄、性别等）

 4.—-默认约束 (Default Counstraint) 该数据的默认值

 5.—-外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列

**（6）oracle5个组函数**

AVG([DISTINCT|ALL]n) 返回平均值，忽略空值 SELECT AVG(sal),SUM(sal) FROM  
EMP WHERE  job LIKE 'SALES%';
  COUNT({*|[DISTINCT|ALL]}expr) 返回记录的数量，用*包含空值，否则不包含空值  SELECT 
COUNT(*) FROM   
emp WHERE   deptno=30;
MAX([DISTINCT|ALL]expr)  返回最大值，忽略空值 SELECT MIN(hiredate),MAX(hiredate) FROM   emp;
MIN([DISTINCT|ALL]expr) 返回最小值，忽略空值
SUM([DISTINCT|ALL]n)  返回总值，忽略空值

**（7）session和cookie的区别**

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中

**（8）客户端跳转与服务器端跳转的区别**

客户端跳转时用HttPservletResopse对象的sendRedirect函数实现

服务器端跳转是使用RequestDispather对象的forward方法实现的

​      区别：

1.   使用服务器端跳转时，客户浏览器的地址栏并不会显示目标地址的URL，而是用客户端跳转时，地址栏当中会显示目标资源的URL

**2.**     **服务器跳转发送两次请求，客户端跳转从始至终只有一次请求**

**3.**     服务器端跳转可以访问当前项目下的所有资源，而客户端跳转只能访问当前目录下的资源。

**（9）一个web工程有几种启动方式**

方式一：   ServletContextListener监听器

方式二： 　ApplicationListener

 方式三：extends HttpServlet

**（10）什么是高内聚低耦合**

**耦合性称为：块间联系**

指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。

**内聚性称为：块内联系**

指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。



## 1.3 编程题（无）





## 1.4 课堂内容

### 1.4.1 idea使用

快捷键	ctrl+shift+r	 	搜索

​		 ctrl+enter		   代码补全

​		CTRL+SHIFT+F	格式化

​		CTRL+SHIFT+R	找类

​		CTRL+SHIFT+O	导包

​		CTRL+ALT+B	       进到方法的实现

​		CTRL+H			全局搜索

### 1.4.2 maven配置

要点：解压完再环境变量配置maven_home，再path配置命令地址（%maven_home%/bin）

再conf目录下的setting.xml下可以配置仓库的地址，配置完之后复制一份到仓库目录下

### 1.4.3 idea创建maven项目

详见 https://www.jianshu.com/u/0b75036451ae

### 1.4.4 依赖管理

依赖的生命周期 provided test compile

依赖传递：父模块可以传递给子模块 如果想要排除依赖需要使用

~~~ <exclusions>
	<exclusions>
            <exclusion>
              <groupId>com.cc.maven</groupId>
              <artifactId>project-c</artifactId>
            </exclusion>
     </exclusions>
	
~~~

如果不想把父模块的依赖传递进来可以在父模块的依赖，可以使用**<dependencyManagement>**标签

~~~
	<dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.data</groupId>
                <artifactId>spring-data-releasetrain</artifactId>
                <version>Fowler-SR2</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>1.5.8.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

~~~



### 1.4.5 svn的使用

### 1.4.6 分模块创建maven项目

先创建一个父项目(maven webapp工程) packaging改为pom

可以将父工程下的webapp删除

在父工程下创建quickstart子工程，packaging可以为jar也可以为war

### 1.4.7 idea中maven插件启动maven工程

在pom.xml中的build配置

~~~
<build>
    <finalName>wanhocrm</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <configuration>
          <port>8088</port>
          <path>/wanhocrm</path>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>7</source>
          <target>7</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
~~~



### 1.4.8 maven中的命令

mvn clean 清理编译后生成的target文件

mvn compile 编译项目变为target文件

mvn package 将编译后的项目打包

mvn install 将项目部署到maven仓库中

### 1.4.9 war包

直接将war包放入tomcat的webapp下，启动tomcat。tomcat会自动解压war包并且进行项目发布

### 1.4.10 相关网站

https://mvnrepository.com/

https://note.youdao.com/share/?id=4c2a6d631db4f00925c365a7f503744e&type=notebook

https://www.jianshu.com/u/0b75036451ae



http://note.youdao.com/noteshare?id=bf299fa7dc9c1b5e23b7e2e480deb528   面试题



https://www.jianshu.com/nb/35159119   ssm

https://blog.csdn.net/isea533/article/details/83045335#3__Mapper_74 mybatis 通用接口Mapper

https://www.jianshu.com/nb/35466597（springboot整合各种资源）



<http://192.168.100.205:8080/filemanager/dialog.php> 大纲





# 2 day02

## 2.1 简答题

**（11）重写和重载的区别**

重写（Override）是父类与子类之间的多态性，实质是对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，不过子类函数的访问修饰权限不能小于父类的；若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。

重载（Overload）是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时通过传递不同参数个数和参数类型来决定具体使用哪个方法的多态性）。

**（12）编程规范是什么**

命名规范 驼峰模式

编码规范 可维护性 高内聚 低耦合

**（13）jquery的ajax请求怎么写？怎么变成同步**

~~~javascript
$.ajax({
    type:'get',
    dataType:'json',
    async:true, //默认是true异步 false则变为同步
    url:'', //servlet
    success:function(data){
    }
})
~~~



**（14）css如何定位元素**

~~~
# id选择器
. class选择器 
html选择器
~~~



**（15）oracle当中如何锁住一个用户；如何解锁一个用户**

~~~
conn sys/sys as sysdba;//以DBA的身份登录
alter user 用户名 account unlock;// 然后解锁
conn scott/tiger //弹出一个修改密码的对话框，修改一下密码就可以了

ALTER USER 用户名 ACCOUNT LOCK
~~~



**（16）oracle当中的分页怎么做**

rownum不能使用大于号进行条件判断 因此需要子查询

~~~
select a1.* from (select student.*,rownum rn from student) a1 where rn >5
~~~



**（17）jsp的三个指令是什么**

~~~
include [page] 静态包含

page
[ language="java" ]
[ extends="package.class" ]
[ import="{package.class | package.*}, ..." ]
[ session="true | false" ]
[ buffer="none | 8kb | sizekb" ]
[ autoFlush="true | false" ]
[ isThreadSafe="true | false" ]
[ info="text" ]
[ errorPage="relativeURL" ]
[ contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ]
[ isErrorPage="true | false" ]

taglib 引用标签库
[prefix]
[uri]  
~~~



**（18）request.getAttribute与request.getParameter的区别**

~~~
getAttribute是向request域中获得对象
getParameter是从request获得前端传递过来的表单数据
~~~



**（19）log4j的作用是什么，几种级别**

~~~
作用：打印日志文件
5种级别
debug info warn error fatal
~~~



**（20）spring当中bean的生命周期有哪些**

~~~
1) spring对bean进行实例化,默认bean是单例
2) spring对bean进行依赖注入
3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法
4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来
5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入
6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法
7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用
8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法
9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁
10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用

作用域：
1.singleton：单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式，配置为：
<bean id="userDao" class="com.ioc.UserDaoImpl" scope="singleton"/>

2.prototype:原型模式，每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。

3.request：在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。
<bean id="loginAction" class="com.cnblogs.Login" scope="request"/>,针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。

4.session：在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。
<bean id="userPreference" class="com.ioc.UserPreference" scope="session"/>,同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。

5.global Session：在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。
~~~



## 2.2 编程题（无）



## 2.3 课堂内容

### 2.3.1 idea中web没有Deployment

在file ---->project structure中 配置facets 添加一个web 

之后点击右下角的create artifacts

### 2.3.2 spring项目中需要的jar包

~~~
spring核心模块
Core Container - 核心容器
spring-core：Spring中的核心工具类包。
spring-beans：Spring中定义bean的组件。
spring-context：Spring的运行容器。
spring-context-support：Spring容器的扩展支持。
spring-expression：Spring的表达式语言支持。

AOP - 面向切面编程
spring-aop：基于代理的AOP支持。
spring-aspects：集成Aspects的AOP支持。

WEB(MVC)
spring-web：提供web的基础功能。
spring-webmvc：提供springmvc的功能。
spring-websocket：提供web socket支持。
spring-webmvc-portlet：提供Portlet环境的支持。

Data Access/Integration - 数据访问/集成
spring-jdbc：提供对jdbc连接的封装功能。
spring-tx：提供对事务的支持。
spring-orm：提供对象－关系映射支持。
spring-oxm：提供对象－XML映射支持。
spring-jms：提供消息队列的支持。

Test - 测试
spring-test：提供对测试功能的支持

log4j以及log4j.properties文件（可加可不加）
~~~



### 2.3.3 log4j

**log4j的五个级别**
debug    info    warn    error    fatal

**log4j使用**

~~~java
Logger logger = Logger.getLogger(SpringDemo1.class);
logger.debug("11");
logger.info("11");
logger.warn("11");
logger.error("11");
logger.fatal("11");
~~~



### 2.3.4 控制反转IOC(Inverse of Control)

~~~java
//java代码
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:beans.xml");
User user = (User) applicationContext.getBean("user");
System.out.println(user);
~~~

~~~xml
<!--xml代码-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
    <bean id="user" class="net.wanho.entity.User"
    </bean>
</beans>
~~~



### 2.3.5 bean的scope取值/生命周期

~~~
1) spring对bean进行实例化,默认bean是单例
2) spring对bean进行依赖注入
3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法
4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来
5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入
6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法
7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用
8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法
9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁
10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用

作用域：
1.singleton：单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式，配置为：
<bean id="userDao" class="com.ioc.UserDaoImpl" scope="singleton"/>

2.prototype:原型模式，每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。

3.request：在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。
<bean id="loginAction" class="com.cnblogs.Login" scope="request"/>,针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。

4.session：在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。
<bean id="userPreference" class="com.ioc.UserPreference" scope="session"/>,同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。

5.global Session：在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。
~~~



### 2.3.6 bean初始化方法

~~~xml
<!--第一种  需要提供set方法和空参构造-->
  <bean id="user1" class="net.wanho.entity.User">
        <property name="name" value="zhangsan"></property>
  </bean>

~~~

~~~xml
<!--第二种 需要提供对应的构造方法-->
<bean id="user1" class="net.wanho.entity.User">
       <constructor-arg name="name" value="zhangsan"></constructor-arg>
</bean>
~~~



### 2.3.7 依赖注入(DI)

~~~xml
<!--依赖注入前提是需要注入的类 需要提供被注入的成员变量的set方法
	之后使用property标签 name是成员变量的名字 ref是在spring配置文件中定义的对应bean的id
-->

<bean id="service" class="net.wanho.service.Service">
        <property name="user" ref="user1"></property>
</bean>
    
<bean id="user1" class="net.wanho.entity.User">
       <constructor-arg name="name" value="zhangsan"></constructor-arg>
</bean>
~~~



### 2.3.8 bean中list/map/set/properties赋值

~~~xml
	<!--前提 需要提供成员变量的set方法-->

	<bean id="user" class="net.wanho.entity.User" p:prop-ref="props" p:name="zhangsan">
        <property name="list">
            <list>
                <value>lisi</value>
                <value>wangwu</value>
            </list>
        </property>
        <property name="map">
            <map>
                <entry key="1" value="2"></entry>
            </map>
        </property>
        <property name="set">
            <set>
                <value>zhaoliu</value>
            </set>
        </property>
        <property name="prop">
            <props>
                <prop key="name">zhangsan</prop>
            </props>
        </property>
    </bean>
~~~



### 2.3.9 util:list的使用（了解）

~~~xml
   <!--可以在bean外面定义一个list/map/set/properties，之后可以通过ref注入 可以用alt+enter自动导入约束-->
    <bean id="user" class="net.wanho.entity.User">
   		<property name="prop" ref="props">	
    </bean>
	

	<util:properties id="props">
        <prop key="name">zhangsan</prop>
        <prop key="sex">male</prop>
    </util:properties>
~~~



### 2.3.10  p标签使用

~~~xml
<!--需要使用alt+shift引入约束  p:成员变量名="值"-->
<bean id="user" class="net.wanho.entity.User" p:prop-ref="props" p:name="zhangsan"></bean>
~~~



### 2.3.11 bean继承和覆盖

~~~xml
<!--创建user和user2时 user2的class会继承user的class属性 如果user2不重写user的p:name 那么成员变量的值也会覆盖-->
<bean id="user" class="net.wanho.entity.User" p:prop-ref="props" p:name="zhangsan"></bean>
<bean id="user2" parent="user" p:name="lisi"></bean>
~~~



### 2.3.12 模板

~~~xml
<!--user继承user2的模板 那么p:name里面的值就会被继承过来-->
<bean id="user2" p:name="lisi" abstract="true"></bean>
<bean id="user" class="net.wanho.entity.User" p:prop-ref="props" parent="user2"></bean>
~~~



### 2.3.13 spring配置文件读取外部资源

~~~xml
 <context:property-placeholder location="classpath:db.properties"></context:property-placeholder>
 
 <bean id="dbcp" class="org.apache.dbcp.BasicDataSource">
 <property name="username" value="${username}"></property>
 </bean>
~~~



### 2.3.14 自动装配

~~~xml
<!--自动装配 会根据类中的成员属性 在spring容器中自动匹配 分为按照类型 byType 即按照成员变量的类型进行查找
byName 即按照成员变量的名字 查找容器中相同id的对象
优：减少代码书写
劣：在配置文件中不能知道哪些成员变量初始化了
-->
<bean id="service" class="net.wanho.service.Service" autowire="byType"></bean>
<bean id="user" class="net.wanho.entity.User"></bean>
~~~



### 2.3.15 spring的init 和destory

~~~xml
<!--调用类中的方法在创建对象之前进行初始化，destory是容器关闭时调用的方法
调用ApplicationContext的destory()方法
-->
<bean id="user" class="net.wanho.entity.User" init-method="init" destory-method="detory"></bean>
~~~



### 2.3.16 depends-on

~~~xml
<!--spring容器创建对象会按照书写顺序进行创建 但如果有些对象依赖于别的对象 那么可以使用depends-on 来改变创建顺序 该对象会在depends-on的对象创建之后再进行创建 -->
<bean id="service" class="net.wanho.service.Service" depends-on="user"></bean>
<bean id="user" class="net.wanho.entity.User"></bean>
~~~



### 2.3.17 svn解决代码冲突

svn在项目文件夹中使用update来更新项目

提交之前需要使用update进行更新

如果有人在你提交代码之前改变了相同的代码 那么就会产生冲突，更新时会出现xxx.mine

xxx.txt.r7

xxx.txt.r10三个文件

mine是自己的代码 复制一份放到别的地方

之后鼠标右键 选择TortoiseSVN--->Revert来覆盖自己的代码

这时本地代码就是线上最新的代码

再把之前复制到别的地方的自己的代码打开 将改变的地方复制进去即可













# 3 day03

## 3.1 简答题

（21）常用的注解有哪些

~~~
@Repository:　　　　用于标注数据访问组件，即DAO组件

@Service:　　　　用于标注业务层组件

@Transactional:　　　　声明这service所有方法都需要事务管理。每一个业务方法开始时都会打开一个事务

@Controller:　　　　控制层

@Component:　　　　把该中立的类交给spring管理

@Autowired:　　　　自动装配，将bean容器里的值自动注入到bean

@Path:　　　　　　处理REST请求,接口路径

@Test			单元测试

@Target 　　表示该注解用于什么地方，可取的值包括：

ElemenetType.CONSTRUCTOR　　　　   构造器声明
ElemenetType.FIELD　　　　　　　　　　域声明（包括 enum 实例）
ElemenetType.LOCAL_VARIABLE　　　  局部变量声明
ElemenetType.METHOD　　　　　　　　 方法声明
ElemenetType.PACKAGE　　　　　　　  包声明
ElemenetType.PARAMETER　　　　　　 参数声明
ElemenetType.TYPE　　　　　　　　　　类，接口（包括注解类型）或enum声明
ElementType.ANNOTATION_TYPE　　   注解
 

@Retention 　　表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括：

RetentionPolicy.SOURCE　　　　　　　注解将被编译器丢弃
RetentionPolicy.CLASS　　　　　　　　注解在class文件中可用，但会被VM丢弃
RetentionPolicy.RUNTIME　　　　　　　JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。
 

@Documented　　 将此注解包含在 javadoc 中

 

@Inherited 　　允许子类继承父类中的注解
~~~



（22）常用的接口有哪些

~~~java
1.java.util.List<E>
2.java.util.Map<E>
3.java.util.Iterator<E>
4.java.sql.CallableStatement
5.java.lang.Comparable<T>
~~~



（23）哪些类可以完成排序

~~~
Arrays
Collections
TreeSet
~~~



（24）哪些类是线程安全的

~~~
vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。

statck：堆栈类，先进后出

hashtable：就比hashmap多了个线程安全

enumeration：枚举，相当于迭代器

StringBuffer是线程安全，而StringBuilder是线程不安全的。
~~~



（25）接口当中有哪些东西是默认的

~~~
常量默认是public static final
方法默认public
~~~



（26）接口和抽象类的区别

~~~
1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。

2、抽象类要被子类继承，接口要被类实现。

3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现

4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。

6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果

7、抽象类里可以没有抽象方法

8、如果一个类里有抽象方法，那么这个类只能是抽象类

9、抽象方法要被实现，所以不能是静态的，也不能是私有的。

10、接口可继承接口，并可多继承接口，但类只能单根继承。
~~~



（27）异常的体系结构

~~~
 Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。 
    其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 
    这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception） 
    和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系： 

    1、Error与Exception 

    Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时， 
    Java虚拟机（JVM）一般会选择线程终止。 


    Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 
    程序中应当尽可能去处理这些异常。 

    2、运行时异常和非运行时异常 

    运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 
    这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 
    程序应该从逻辑角度尽可能避免这类异常的发生。 

    非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 
    从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 
    如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 
~~~



（28）集合的体系结构

~~~
Collection
├List （有序集合，允许相同元素和null）
│├LinkedList （非同步，允许相同元素和null，遍历效率低插入和删除效率高）
│├ArrayList （非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多）
│└Vector（同步，允许相同元素和null，效率低）
│　└Stack（继承自Vector，实现一个后进先出的堆栈）
└Set （无序集合，不允许相同元素，最多有一个null元素）
   |-HashSet(无序集合，不允许相同元素，最多有一个null元素)
 

Map （没有实现collection接口，key不能重复，value可以重复，一个key映射一个value）
├Hashtable （实现Map接口，同步，不允许null作为key和value，用自定义的类当作key的话要复写hashCode和eques方法，）
├HashMap （实现Map接口，非同步，允许null作为key和value，用的多）
└WeakHashMap（实现Map接口）
~~~



（29）linux的分类有哪些

~~~
主流的Linux发行版　Ubuntu， Debian GNU/Linux ，Fedora ，Gentoo ，MandrivaLinux ，PCLinuxOS，Slackware Linux ，openSUSE，ArchLinux，Puppylinux，Mint, CentOS,Red Hat等 中国大陆的Linux发行版 　　中标麒麟Linux(原中标普华Linux)， 红旗Linux(Red-flag Linux) ，Qomo Linux(原Everest)，冲浪Linux(Xteam Linux) ，蓝点Linux ，新华Linux ，共创Linux ，百资Linux ，veket, lucky8k-veket.Open Desktop ，Hiweed GNU/Linux ，Magic Linux ，Engineering Computing GNU/Linux ，kylin，中软Linux ，新华华镭Linux(RaysLX) ，CD Linux ，MC Linux ，即时Linux(Thizlinux) ，b2d linux ，IBOX ，MCLOS ，FANX，酷博linux，新氧Linux，Hiweed，Deepin Linux，雨林木风YLMF OS
~~~



（30）你听过哪些数据库技术

~~~
DB2 MYSQL ORACLE MongoDB ACCESS
~~~



## 3.2 编程题



## 3.3 课堂内容

### 3.3.1  spring包扫描

```xml
<!--package选择需要扫描的包-->
<context:component-scan base-package="net.wanho.service,net.wanho.proxy"></context:component-scan>
```

~~~java
//需要配置注解
@Component
@Controller//Controller层
@Service//Service层
@Repository//Dao层
@AutoWired//自动装配
@Resource//自动装配 实际工作中写这个 因为属于jdk 比较轻 不受其他的影响
//实际使用中是在Controller层定义Service接口的成员变量 然后自动装配
//配置的方式 优于 注解的方式
~~~

~~~xml
<!--扫描这些包 exclude 但不扫描Repository注解  include 扫描这些注解 基本没用-->
<context:component-scan base-package="net.wanho.service,net.wanho.proxy">
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"></context:exclude-filter>
    	 <context:include-filter type="annotation" 	expression="org.springframework.stereotype.Repository"></context:include-filter>
 </context:component-scan>
~~~

~~~xml
<!--resource-pattern 资源匹配 只扫描满足里面表达式的包-->
<context:component-scan base-package="net.wanho.service,net.wanho.proxy" resource-pattern="*controller*/*.class">
~~~



### 3.3.2 lombok

~~~xml
<!--添加依赖--> 
<dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.4</version>
 </dependency>
~~~

~~~java
//添加在Pojo类的上面 能自动生成构造方法 set get
@AllArgsConstructor//所有有参构造
@NoArgsConstructor//无参构造
@Data//setter getter方法
~~~

使用lombok需要安装一个插件 打开file>>settings>>plugins>>搜索lombok>>安装

### 3.3.3 jdk动态代理

~~~java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyTest implements InvocationHandler {
    Object targetObj;

    public Object getInstance(Object targetObj){
        this.targetObj = targetObj;
        return Proxy.newProxyInstance(this.targetObj.getClass().getClassLoader(),targetObj.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object obj = null;
        System.out.println("start");
        obj = method.invoke(targetObj,args);
        System.out.println("end");
        return obj;
    }
}
~~~



### 3.3.4 注解的aop

~~~xml
//在切面类上打上注解
@Component
@Aspect
//在spring配置文件中配置 会进行扫描注解了@Aspect的类
 <aop:aspectj-autoproxy proxy-target-class="false"></aop:aspectj-autoproxy> 如果为false（默认值） 则使用的是jdk的动态代理类  如果为true 则使用的是cglib的动态代理
~~~

~~~java
//Before 和 After 表示执行前调用还是执行后调用这个切面方法  还有AtferThrowing  AtferReturning
@Component
@Aspect
public class AspectProxy {

    @After("execution(* net.wanho.*.*.*(..))")
    public void after(JoinPoint joinPoint){
       joinPoint.getSignature().getName();//可以获得执行的类的名字
       joinPoint.getTarget().getClass().getName();//可以获得代理类的名字
       System.out.println("after.....");
    }
}
~~~

~~~java
//Around 环绕  需要一个Object返回值（类似于jdk动态代理） 以及形参ProceedingJoinPoint 
@Component
@Aspect
public class AspectProxy {

    @Around("execution(* net.wanho.*.*.*(..))")
    public Object around(ProceedingJoinPoint joinPoint){
        System.out.println("start");
        Object obj= null;
        try {
         obj  = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println("end");
        return obj;
    }
}
~~~

### 3.3.5 配置的aop

~~~xml
<!--配置切面类-->
<bean id="logger" class="net.wanho.proxy.AspectProxy"></bean>

    <aop:config>
        <!--配置切入点-->
        <aop:pointcut id="pointcut" expression="execution(* net.wanho.service.*.*(..))"></aop:pointcut>
        <!--配置切入方法和切入时机-->
        <aop:aspect ref="logger">
            <aop:before method="before" pointcut-ref="pointcut"/>
        </aop:aspect>
    </aop:config>
~~~



### 3.3.6 linux

~~~java
//安装jdk
systemctl stop firewalld.service	//关闭防火墙
yum -y install docker-io			//安装docker
tar -xvf jdk-8u162-linux-x64.tar.gz	//tar解压
ls
cd jdk1.8.0_162/				
pwd
export JAVA_HOME=/root/jdk1.8.0_162	//配置全局变量
echo $JAVA_HOME
export PATH=$JAVA_HOME/bin:$PATH	//配置PATH全局变量
echo $PATH						//查看PATH
java -version	
cd
ls


//安装tomcat
unzip apache-tomcat-8.5.38.zip	//zip解压
ls
cd apache-tomcat-8.5.38/bin/
ls
ll
chmod 777 *					//更改执行权限
ll
./startup.sh				//启动tomcat
cd ..
cd logs/
tail -f catalina.out		//查看catalina日志
netstat -luntp|grep 8080	//查看端口是否占用
systemctl stop firewalld.service	//关闭防火墙
    
//安装mysql
rpm -qa!grep mysql //检查是否安装过mysql
rpm -e mysql-libs --nodeps  //删除安装的mysql包
yum install -y mysql-server mysql mysql-devel //安装mysql
service mysqld start //启动mysql
service mysqld status //检验是否启动成功
netstat -luntp|grep 3306  //验证是否启动成功方式二 看端口
chkconfig --list|grep mysql //查看是否又开机启动
chkconfig mysqld on //设置开机启动
mysqladmin -u root password '123' //这只root密码为123
mysql -uroot -p123 //登陆验证


//centos7 不支持mysql服务  使用mariaDB来启动mysql
# yum install mariadb-server -y //如果已安装可以省略  
# systemctl start mariadb.service //启动服务  
# systemctl enable mariadb.service //开机启动服务  
# mysql -uroot -p123	 //登录mysql  


 
//安装docker和安装redis
yum -y install docker-io	//安装docker
    
lsof -i:8080  //查看端口正在运行的进程pid
kill -9 25523				//杀死一个进程
yum -y install docker-io
docker images			//查看docker安装的服务
service docker start	//启动docker服务
service docker status	//查看docker状态
docker images			
docker search redis		//搜索redis服务
docker pull redis		//下载redis
history					//查看执行过的命令（linux）
docker commit 容器id/名称  mytomcat	//启动一个docker

docker run -p 6379:6379 --name myredis 0f88f9be5839  //开启一个docker容器-p 端口  --nae 容器名字 服务的image id
docker start myredis 	//启动容器
docker ps			//查看启动的容器
docker exec -it myredis bash	//进入启动的容器的服务
redis-cli			//进入redis客户端
docker images
docker status
service docker stop		//关闭docker服务
docker ps -a 			//查看创建的容器
docker save -o mytomcat.tar mytomcat
docker load -i mytomcat.tar

//docker安装tomcat和mysql 和安装redis一样 

//docker容器迁移
docker save -o mytomcat.tar mytomcat  //打包容器
docker load -i mytomcat.tar	 		//读取容器

docker rm -f mytomcat    	//删除容器



~~~

## 3.4 作业简答题

​    **1，简述面向对象的三大特征**

~~~
1、抽象性。

抽象是指强调实体的本质、内在的属性。在系统开发中，抽象指的是在决定如何实现对象之前的对象的意义和行为。使用抽象可以尽可能避免过早考虑一些细节。

2、继承性。

继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。

3、多态性

多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。
~~~



​    **2，解释一处编译到处运行的含义**

~~~
“一次编译、到处运行”说的是Java语言跨平台的特性，简单地来讲，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。
~~~



​    **3，实现多线程有几种方式**

~~~
1.继承Thread类，重写run方法
2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
3.通过Callable和FutureTask创建线程
4.通过线程池创建线程
~~~



​    **4，使用反射如何创建一个对象，如何调用一个方法**

~~~
1.通过Class.forName(“包名+方法的类名”)拿到方法的对象;

如：Class<?> clazz = Class.forName("ReflectionTest");

        也可以通过实例，获取方法的对象类，

        如：String str = "test , reflection";

        Class<?> clazz = str.getClass();

2.明确反射方法名称

3.明确方法的参数类型，就可以拿到对象的方法。

如：Method method = clazz.getMethod("test",String.class,int.class)；

4.实例化对象,可以直接调用已创建的对象，也可以newInstance()一个。

5.确定具体方法的参数

如:     Object obj1 = method.invoke(clazz.newInstance(),"xiaojun",23);

       System.out.println("直接反射："+obj1);
~~~



​    **5，简述样式和内容的分离**

~~~
在 Web 开发中，所谓内容与样式分离，就是让内容的归 HTML, 样式归 CSS, 不要混着用。
~~~



​    **6，ajax的核心含义是什么**

~~~
核心就是异步加载 实现页面的局部刷新
~~~



​    **7，解释servlet的生命周期**

~~~
init方法
        在一个Servlet的生命周期中，init方法只会被执行一次，之后无论用户执行多少次请求，都不会在调用该方法。 
        关于init方法的执行时机，有两种方式可选，一般的是在服务器启动后第一个用户请求改Servlet是调用，你也可以设置该Servlet在服务器启动后自动执行。 
init方法负责简单的创建或者加载一些数据，这些数据将用于该Servlet的整个生命周期中。

service方法
        当一个客户请求改Servlet时，实际的处理工作全部有service方法来完成，service方法用来处理客户端的请求，并生成格式化数据返回给客户端。 
        每一次请求服务器都会开启一个新的线程并执行一次service方法，service根据客户端的请求类型，调用

destroy方法
        该方法在整个生命周期中，也是只会被调用一次，在Servlet对象被销毁是调用，在servlet中，我们可以做一些资源的释放等操作，执行destory方法之后的servlet对象，会等待jvm虚拟机的垃圾回收机制择时回收。

~~~



​    **8，servlet的作用域有哪些**

~~~
ServletContext/ApplicationContext
Session
Request
PageContext
~~~



​    **9，解释mvc以及springmvc配置的关键点**

~~~

~~~



​    **10，解释控制反转和依赖注入**

~~~
Ioc—Inversion of Control
	即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

DI(依赖注入)
	是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。
~~~



​    **11，区分String s = "123"；与 String s1 = new String("123")**

~~~
String s="123" 创建一个“123” 放入常量池中
String s=new String("123") 创建两个对象，首先new String()的参数是String对象，创建“123”放入常量池，然后在new一个对象放入堆中
~~~



​    **12，运行时异常是什么，举5个例子**

~~~
运行时异常：我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。
ClassCastException, 
IllegalArgumentException, 
NullPointerException, 
IndexOutOfBoundsException, 
SystemException,
BufferOverflowException
~~~



​    **13，oracle中的约束有哪几类，举例说明**

~~~
NOT NULL (非空)--防止NULL值进入指定的列,在单列基础上定义,默认情况下,ORACLE允许在任何列中有NULL值.
CHECK (检查)--检查在约束中指定的条件是否得到了满足.
UNIQUE (唯一)--保证在指定的列中没有重复值.在该表中每一个值或者每一组值都将是唯一的.
PRIMARY KEY (主键)--用来唯一的标识出表的每一行,并且防止出现NULL值,一个表只能有一个主键约束.
POREIGN KEY (外部键)--通过使用公共列在表之间建立一种父子(parent-child)关系,在表上定义的外部键可以指向主键或者其他表的唯一键.
~~~



​    **14，ddl, dcl, dml, dql的区别是什么**

~~~
1. 数据查询语言DQL
数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE
子句组成的查询块：
SELECT <字段名表>
FROM <表或视图名>
WHERE <查询条件>

2 .数据操纵语言DML
数据操纵语言DML主要有三种形式：
1) 插入：INSERT
2) 更新：UPDATE
3) 删除：DELETE

3. 数据定义语言DDL
数据定义语言DDL用来创建数据库中的各种对象-----表、视图、
索引、同义词、聚簇等如：
CREATE TABLE/VIEW/INDEX/SYN/CLUSTER
| | | | |
表 视图 索引 同义词 簇

DDL操作是隐性提交的！不能rollback 

4. 数据控制语言DCL
数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制
数据库操纵事务发生的时间及效果，对数据库实行监视等。如：
1) GRANT：授权。


2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。
回滚---ROLLBACK
回滚命令使数据库状态回到上次最后提交的状态。其格式为：
SQL>ROLLBACK;


3) COMMIT [WORK]：提交。
~~~



​    **15，css的三种选择器是什么**

~~~
id选择器 class选择器 html选择器
~~~



​    **16，有哪几种标签可以向后台发起数据请求**

~~~
srcipt
link
a
form
img
~~~



​    **17，tomcat的目录结构有哪些，分别代表什么作用；类似的容器还有哪些**

~~~
/bin                        存放启动和关闭tomcat的脚本文件
/common/lin         存放Tomcat服务器及所有Web应用程序都可以访问的jar文件
/conf                      存放Tomcat服务器的各种配置未见，其中包括server.xml（Tomcat的主要配置文件）、tomcat-user.xml和web.xml等配置文件
/logs                       存放Tomcat的日志文件
/server/lib               存放Tomcat服务器运行所需要的各种jar文件
/server/webapps     存放Tomcat的两个Web应用程序，admin应用程序和manager应用程序
/shared/lib                存放所有Web应用程序都可以访问的Jar文件
/temp                        存放Tomcat运行时候产生的临时文件
/webapps                当发布Web应用程序的时候，通常把Web应用程序的目录以及文件放到这个目录下
/work                        Tomcat将JSP产生的Servlet源文件和字节码存放在这个文件目录下

类似的容器有Jetty（开源）, Resin（开源）
~~~



​    **18，实现servlet有几种方式**

~~~
1.实现Servlet接口
2.继承GenericServlet抽象类 GenericServlet抽象类中只有一个抽象方法service()方法
3.继承HttpServlet抽象类重写doPut()和doPost()方法
~~~



​    **19，log4j的作用是什么？有几种级别？一般再发布的时候修改为什么级别，为什么**

~~~
作用：打印日志文件
5种级别
debug info warn error fatal
发布时修改为error 因为只记录出错的信息 减少io写入时的内存占用
~~~



​    **20，如何实现mybatis的二级缓存**



​    **21，final, finally, finalize的区别； throw , throws的区别；break ,continue, return的区别； if else/ switch case defualt的区别；interface与抽象类的区别；重写与重载的区别；对象的上转型与面向接口编程的区别；**

~~~
1、final修饰符（关键字）。
被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将变量或方法声明为final，可以保证他们在使用的过程中不被修改。

2、finally是在异常处理时提供finally块来执行任何清除操作。
不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。

3、finalize是方法名。
java技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize方法以整理系统资源或者被执行其他清理工作。

throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。

break跳出循环 continue不执行当前循环下面的语句 开始下一次循环
return 方法结束 返回值

switch case default只能用于case值为常量的分支结构，而if…else…更加灵活。
if判断条件为逻辑表达式，可以是布尔类型的合法表达式、可以是常量、枚举等。而switch 通常处理算术表达式，或字符。。
分支较多时，使用switch的效率高于if，除非第一个if条件就为真。。

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
2、抽象类要被子类继承，接口要被类实现。
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
7、抽象类里可以没有抽象方法
8、如果一个类里有抽象方法，那么这个类只能是抽象类
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。
10、接口可继承接口，并可多继承接口，但类只能单根继承。

对象向上转型
B是A的子类或间接子类，当我们用子类B创建一个对象，并把这个对象的引用放到类A声明的对象中

面向接口编程
在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。


~~~



​    **22，String, StringBuilder, StringBuffer的区别是什么**

~~~
String 不可变字符序列
StringBuilder 线程不安全的可变字符序列
StringBuffer 线程安全的可变字符序列
~~~



​    **23，解释笛卡尔乘积，水平过滤，垂直过滤**

~~~
笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员


~~~



​    **24，数据库的组函数有哪些？怎么使用**

~~~
1、COUNT ()返回查寻的行数

例如：select count(*) from table;

2、MAX() 返回表达式的最大值

例如：select a, max(b) from table group by a;

3、MIN() 返回表达式的最小值

例如：select a, min(b) from table group by a;

4、SUM() 返回表达式的总合

例如：select a, sum(b) from table group by a;

5、AVG() 返回表达式的平均值

例如：select a, avg(b) from table group by a。
~~~



​    **25，如何做到页面加载完毕就执行js语句；**

~~~javascript
//方式一：

window.onload=function(){

var userName="xiaoming"; 

alert(userName); 
}


//方式二：
$(document).ready(function(){ 

var userName="xiaoming"; 

alert(userName); 
}); 
//方式二可简写为：
$(function(){ 
var userName="xiaoming"; 
alert(userName); 
});
~~~



​    **26，input的类型有哪些**

~~~
text、password、number、button、reset、submit、hidden、radio、checkbox、file、image、color、range、date、month、week、time、datetime-local。

HTML5:tel、email、url、datetime、search。这些类型部分浏览器不支持识别或校验。
~~~



​    **27，解释监听器、过滤器以及servlet以及拦截器的区别**

~~~
 1,servlet 流程是短的，url传来之后，就对其进行处理，之后返回或转向到某一自己指定的页面。它主要用来在 业务处理之前进行控制.
 
2,filter 流程是线性的， url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter, servlet接收等，而servlet 处理之后，不会继续向下传递。filter功能可用来保持流程继续按照原来的方式进行下去，或者主导流程，而servlet的功能主要用来主导流程。
filter可用来进行字符编码的过滤，检测用户是否登陆的过滤，禁止页面缓存等
         
3, servlet,filter都是针对url之类的，而listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。
     可用来进行：Spring整合Struts,为Struts的action注入属性，web应用定时任务的实现，在线人数的统计等
 
4，interceptor 拦截器，类似于filter,不过在struts.xml中配置，不是在web.xml,并且不是针对URL的，而是针对action,当页面提交 action时，进行过滤操作，相当于struts1.x提供的plug-in机制，可以看作，前者是struts1.x自带的filter,而 interceptor 是struts2 提供的filter.
与filter不同点：
(1)	在web.xml中配置，而是在struts.xml中完成配置，与action在一起
(2) 可由action自己指定用哪个interceptor 来在接收之前做事    

5，struts2中的过滤器和拦截器的区别与联系：

      （1）、拦截器是基于java反射机制的，而过滤器是基于函数回调的。
      （2）、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器。
      （3）、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
      （4）、拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。
      （5）、在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。
~~~



​    **28，解释服务器端跳转和客户端跳转**

~~~
服务器端跳转：又称为内部跳转，当客户端向服务器发送一个请求，请求当前资源时，这个资源在服务器内部跳转到另一个资源，再向客户端发送一个响应（即客户端只产生了一次请求）。 
客户端跳转：又称为外部跳转，当客户端向服务器发送一个请求，请求当前资源时，这个资源向客户端发送一个去请求其他地址的回应。客户端再根据这个地址去进行下一次请求（即客户端产生了两次请求）。

区别
1. 使用服务器端跳转时，客户浏览器的地址栏并不会显示目标地址的URL，而是用客户端跳转时，地址栏当中会显示目标资源的URL；

2. 服务器端跳转是由客户端发送一个请求，请求一个服务器资源——如JSP和Servlet——，这个资源又将请求转到另一个服务器资源，然后再给客户端发送一个响应，也就是说服务器端跳转是客户端发送一次请求，服务器端给出一次响应；而客户端跳转的流程则不同。客户端同样是发送一个请求给服务器端资源，这个服务器资源会首先给客户端一个响应，客户端再根据这个响应当中所包含的地址，再次向服务器端发送一个请求，也就是说客户端跳转是两次请求，两次响应；

3. 在进行客户端跳转和服务器端跳转时，都需要指定目标资源的URL，如果这个路径以“”开始。在客户端跳转当中“”代表的是应用服务器根目录，而在服务器端跳转当中代表的是应用程序根目录。
~~~



​    **29，延迟加载是什么意思**

~~~
延迟加载(lazy load)是(也称为懒加载)Hibernate3关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。
~~~



​    **30，介绍一下shiro**

~~~
Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。

三个核心组件：Subject, SecurityManager 和 Realms.
Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。
　　Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。
　　SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。
　　Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。
　　从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。
　　Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。
~~~









# 4 day 04

## 3.1 简答题

**（1）oracle当中存储过程和存储函数的区别**

~~~
标识符不同：函数的标识符为FUNCTION；

　　　　　　存储过程为：PROCEDURE。

参数：   存储过程的参数列表可以有输入参数、输出参数、可输入输出的参数；

            函数的参数列表只有输入参数，并且有return <返回值类型，无长度说明>。

返回值上：

　　　　存储过程的返回值，可以有多个值，

           函数的返回值，只有一个值。

调用方式上：

　　　　存储过程的调用方式有：

1)、exec <过程名>;

2)、execute <过程名>;

3)、在PL/SQL语句块中直接调用。

            函数的调用方式有：

　　　　　　在PL/SQL语句块中直接调用。
~~~



**（2）oracle当中如何实现主键自增，mysql当中呢**

~~~
oracle: 建立序列 sequence
mysql:主键使用关键字auto_increament
~~~



**（3）常见的linux服务器有哪些**

~~~
主流的Linux发行版　Ubuntu， Debian GNU/Linux ，Fedora ，Gentoo ，MandrivaLinux ，PCLinuxOS，Slackware Linux ，openSUSE，ArchLinux，Puppylinux，Mint, CentOS,Red Hat等 中国大陆的Linux发行版 　　中标麒麟Linux(原中标普华Linux)， 红旗Linux(Red-flag Linux) ，Qomo Linux(原Everest)，冲浪Linux(Xteam Linux) ，蓝点Linux ，新华Linux ，共创Linux ，百资Linux ，veket, lucky8k-veket.Open Desktop ，Hiweed GNU/Linux ，Magic Linux ，Engineering Computing GNU/Linux ，kylin，中软Linux ，新华华镭Linux(RaysLX) ，CD Linux ，MC Linux ，即时Linux(Thizlinux) ，b2d linux ，IBOX ，MCLOS ，FANX，酷博linux，新氧Linux，Hiweed，Deepin Linux，雨林木风YLMF OS
~~~



**（4）什么是程序、进程、线程**

~~~
程序：是计算机指令的集合，以文件的形式存储在磁盘上。

进程:是一个程序在其 自身的地址空间中的一次执行活动。资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源，而程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占系统的运行资源。

线程：进程中的一个单一的连续控制流程。一个进程可以拥有多个线程。
线程又称轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度，区别在于线程没有独立的存储空间，而是和所属进程中的其它线程共享一个存储空间，这使得线程间的通信远较进程简单。
~~~



**（5）wait以及sleep的区别**

~~~
对于sleep()方法，是属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。

在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
~~~



**（6）线程的状态有哪些，如何切换**

~~~
1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。

2.运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。

线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

3.阻塞(BLOCKED)：表示线程阻塞于锁。

4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。

6.终止(TERMINATED)：表示该线程已经执行完毕。

~~~



**（7）jdk8的新特性有哪些**

~~~
1.Lambda表达式

2.Stream函数式操作流元素集合

3.接口新增：默认方法与静态方法

4.方法引用,与Lambda表达式联合使用

5.引入重复注解

6.类型注解

7.最新的Date/Time API (JSR 310)

8.新增base64加解密API

9.数组并行（parallel）操作

10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间
~~~



**（8）如何优化sql查询**

~~~sql
1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

　　select id from t where num is null

　　可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

　　select id from t where num=0

3、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

　　select id from t where num=10 or num=20

　　可以这样查询：

　　select id from t where num=10

　　union all

　　select id from t where num=20

5、in 和 not in 也要慎用，否则会导致全表扫描，如：

　　select id from t where num in(1,2,3)

　　对于连续的数值，能用 between 就不要用 in 了：

　　select id from t where num between 1 and 3

6、下面的查询也将导致全表扫描：

　　select id from t where name like '%abc%'

　　若要提高效率，可以考虑全文检索。

7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：

　　select id from t where num=@num

　　可以改为强制查询使用索引：

　　select id from t with(index(索引名)) where num=@num

8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：

　　select id from t where num/2=100

　　应改为:

　　select id from t where num=100*2

9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：

　　select id from t where substring(name,1,3)='abc'--name以abc开头的id

　　select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id

　　应改为:

　　select id from t where name like 'abc%'

　　select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'

10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

12、不要写一些没有意义的查询，如需要生成一个空表结构：

　　select col1,col2 into #t from t where 1=0

　　这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：

　　create table #t(...)

13、很多时候用 exists 代替 in 是一个好的选择：

　　select num from a where num in(select num from b)

　　用下面的语句替换：

　　select num from a where exists(select 1 from b where num=a.num)＼

14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。

15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

21、避免频繁创建和删除临时表，以减少系统表资源的消耗。

22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。

23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

29、尽量避免大事务操作，提高系统并发能力。

30、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
~~~



**（9）子查询和表连接，哪个效率高**

~~~
表连接
~~~



**（10）maven的作用是什么，什么是中央仓库、本地仓库？什么是私服？**

~~~
Maven是一个项目管理工具，它包括：项目对象模型（Project Object Model）和依赖管理系统（Dependency Management System）
中央仓库是Maven官方提供的下载jar包的网上位置
Maven本地仓库的默认位置为 
C:\Users\Administrator.m2\repository 
repository 即为仓库，在项目构建时，Maven会自动向该文件夹下载项目所需jar包。
私服是私有服务器,是公司内部Maven项目经常需要的。Nexus是常用的私用Maven服务器,一般是公司内部使用。
~~~



**（11）解释脏读、幻读、不可重复读**

~~~
  脏读(Dirty read)：在一个事务中读取到另一个事务已经修改但没有提交的数据。例如，事务A对数据进行了修改，但是还没有提交，这时事务B读取这个数据，然后事务A回滚，那么事务B取的数据无效。不符合一致性。

  不可重复读(NonRepeatable Read)：既不能读到相同的数据内容，事务A读取到了事务B已经提交的修改数据（一个事务范围内两个相同的查询却返回了不同数据）。例如事务A先读取数据，然后事务B对该同一数据修改并提交，那么事务A再次读取该数据时，由于事务B对该数据的修改，事务A两次读到的的数据可能是不一样的。不符合隔离性。

  幻读(Phantom Read)：事务A读取到了事务B已经提交的新增数据。在一个事务中，两次查询的结果不一致(针对的insert操作) 。例如事务A对一个表中的数据进行了修改，同时，事务B也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，事务A的用户后面的操作发现表中还有没有修改的数据行，就好象发生了幻觉一样。不符合隔离性。
~~~







## 3.2 编程题



## 3.3 课堂内容

### 3.3.1 spel

~~~xml
 <!--用#{}来表示spel表达式 可以在里面用上面定义的bean的属性和方法-->
 <bean id="user" class="net.wanho.entity.User">
        <property name="name" value="lvliang"></property>
    </bean>

    <bean id="user1" class="net.wanho.entity.User">
        <property name="name" value="#{user.name}"></property>
    </bean>

    <bean id="user2" class="net.wanho.entity.User">
        <property name="name" value="#{user1.getName()}"></property>
    </bean>

    <bean id="user3" class="net.wanho.entity.User">
        <property name="name" value="#{T(java.lang.Math).PI}"></property>
    </bean>
~~~



### 3.3.2 后置处理器

~~~java
//自己写一个实现类 实现BeanPostProcessor接口 两个方法分别是在spring创建对象后 调用玩init-method方法前后执行 Object o 就是spring当前正在创建的类
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
        System.out.println("before init");
        return o;
    }

    @Override
    public Object postProcessAfterInitialization(Object o, String s) throws BeansException {
        System.out.println("after init");
        return o;
    }
}
~~~



~~~xml
<!--配置上面自己实现的类 不需要引用 spring会在创建该对象时调用 配置的init-method方法前后执行实现类中的两个方法--> 
<bean id="user" class="net.wanho.entity.User" init-method="initMethod">
        <property name="name" value="lvliang"></property>
    </bean>

    <bean class="net.wanho.controller.MyBeanPostProcessor"></bean>
~~~



### 3.3.3 动态工厂

~~~java

//定义工厂类 里面初始化工厂中的对象
public class InstanceStudentFactory {
    private Map<Integer,User> stuMap = new HashMap<>();
    {
        stuMap.put(1001,new Student(1001,"zhangsan"));
        stuMap.put(1002,new Student(1002,"lisi"));
    }

    public User getUser(int id){
        return stuMap.get(id);
    }
}

//Test方法调用xml中配置的bean
application.getBean("stu2");
~~~

~~~xml
<!--配置工厂类--> 
<bean id="factory" class="net.wanho.factory.InstanceStudentFactory"></bean>

 <bean id="stu2" factory-bean="factory" factory-method="getUser">
     <constructor-arg value="1002"></constructor-arg>
 </bean>
~~~



### 3.3.4 静态工厂

~~~java

public class StaticStudentFactory {
    private static Map<Integer,User> stuMap = new HashMap<>();
    static {
        stuMap.put(1001,new Student(1001,"zhangsan"));
        stuMap.put(1002,new Student(1002,"lisi"));
    }
    public static User getUser(int id){
        return stuMap.get(id);
    }
}
~~~

~~~xml
<!--使用方法同动态工厂-->
<bean id="stu" class="net.wanho.factory.StaticStudentFactory" factory-method="getUser">
        <constructor-arg value="1001"></constructor-arg>
</bean>
~~~



### 3.3.5 FactoryBean

~~~java
//提供成员属性是为了在spring中配置property的时候注入值，根据值来初始化User对象中的成员属性
//isSingleton true代表单例
public class UserFactoryBean implements FactoryBean<User> {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public User getObject() throws Exception {
        User user = new User();
        user.setName(name);
        return user;
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}

//Test直接调用配置的工厂bean的id即可获得User对象
application.getBean("user")
~~~

~~~xml
    <!--配置该工厂-->
	<bean id="user" class="net.wanho.factory.UserFactoryBean">
        <property name="name" value="lvliang"></property>
    </bean>
~~~



### 3.3.6 切面的优先级

~~~java
//注解的切面类上加上一个注解@Order(1) @Order(2) 数字越小代表优先级越高 切面类先执行
@Order(1)
@Component
@Aspecct
public class LoggingAspect{
    
}
~~~



### 3.3.7 重用切入点

~~~java
	//切入点定义在外面 方法返回必须void 没有返回值 函数体为空
	@Pointcut("execution(* net.wanho.Service.*.*(..))")
    public void declarePointExpression(){}
	
	//里面直接调用上面定义的切入点的方法即可
    @Before("declarePointExpression()")
    public void beforeMethod(JoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
    }
~~~



### 3.3.8 合并切入点

~~~java
	//多个切入点可以用逻辑或 来进行合并
	@Pointcut("execution(* net.wanho.Service.*.delete*(..))||execution(* net.wanho.Service.*.add*(..))")
    public void declarePointExpression(){}

    @Before("declarePointExpression()")
    public void beforeMethod(JoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
    }
~~~



### 3.3.9 搭建jdbcTemplate

~~~xml
	<!--配置数据库连接池-->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://127.0.0.1:3306/day13"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123"></property>
    </bean>
	
	<!--配置jdbcTemplate-->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

	<!--扫描并且注入jdbcTemplate-->
	<context:component-scan base-package="net.wanho.Service"></context:component-scan>
~~~

~~~java
//jdbcTemplate的使用
public void add() throws Exception{
        temp.update("insert into account(name,money) values(?,?)","ll3","100");
        temp.update("insert into account(name,money) values(?,?)","ll2","100");
        List<Account> list = temp.query("select * from account", new BeanPropertyRowMapper<>(Account.class));
    }
~~~



### 3.3.10 批量插入

~~~java
    //由于插入可能有多个值 因此需要传递的是object的数组
    public void insert(){
        List<Object[]> list = new ArrayList<>();
        list.add(new Object[]{"zhangsan"});
        list.add(new Object[]{"lisi"});
        list.add(new Object[]{"sangwu"});
        temp.batchUpdate("insert into account(name) values(?)",list);
    }
~~~



### 3.3.11 查询一条记录

~~~java
Account account = temp.queryForObject("select * from account where id=? and name=?", new Object[]{1, "zhangsan"}, new BeanPropertyRowMapper<>(Account.class));
~~~



### 3.3.12 具名参数

~~~xml
    <bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
        <constructor-arg ref="dataSource"></constructor-arg>
    </bean>
~~~

~~~java
  //在sql语句中参数前面加上冒号+map中的key  如  :name
	public static void main(String[] args) {
        ApplicationContext app = new ClassPathXmlApplicationContext("classpath:bean.xml");
        NamedParameterJdbcTemplate temp = app.getBean(NamedParameterJdbcTemplate.class);
        Map<String,String> map = new HashMap<>();
        map.put("name","lvliang");
        temp.update("insert into account(name) values(:name)",map);
    }
~~~



### 3.3.13 事务的注解配置

~~~xml
	<!--扫描方法记得给service添加@Service 并且配置包扫描  或者手动配置service的bean-->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://127.0.0.1:3306/day13"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123"></property>
    </bean>
	
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
~~~

~~~java
//在需要事务的方法上加上@Transactional注解 但是默认只会回退RunTimeExceptin 因此需要加上(rollbackFor = Exception.class) 表示所有的异常都会回退  (readOnly=true)表示这个事务里面只能select 不能增删改

@Transactional(rollbackFor = Exception.class)
    public void add() throws Exception{
        temp.update("insert into account(name,money) values(?,?)","ll3","100");
        temp.update("insert into account(name,money) values(?,?)","ll2","100");
        List<Account> list = temp.query("select * from account", new BeanPropertyRowMapper<>(Account.class));
    }
~~~



### 3.3.14 事务的配置方法

~~~xml
<!--扫描方法记得给service添加@Service 并且配置包扫描  或者手动配置service的bean-->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://127.0.0.1:3306/day13"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123"></property>
    </bean>
	
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    
    <tx:advice id="advice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="add*" rollback-for="java.lang.Exception"/>
            <tx:method name="update*" rollback-for="java.lang.Exception"/>
            <tx:method name="delete*" rollback-for="java.lang.Exception"/>
            <tx:method name="*" read-only="true"/>
        </tx:attributes>
    </tx:advice>

    <aop:config>
        <aop:pointcut id="pointcut" expression="execution(* net.wanho.Service.*.*(..))"></aop:pointcut>
        <aop:advisor advice-ref="advice" pointcut-ref="pointcut"></aop:advisor>
    </aop:config>
~~~



### 3.3.15 事务的隔离级别和传播特性

~~~xml
<!--propagation是设置传播特性 isolation是设置隔离级别--> 
	<tx:advice id="advice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="add*" rollback-for="java.lang.Exception" propagation="REQUIRED" isolation="READ_COMMITTED"/>
        </tx:attributes>
	</tx:advice>
~~~

~~~java
//事务的传播行为 七种
propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。
propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。
propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。
propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。
propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

//事务的隔离级别 四种
read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。
read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。
repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。
serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。
~~~



### 3.3.16 有趣的接口

~~~java
Servlet, Filter, InvacationHandler, BeanPostProcessor，Serializeable, FactoryBean, ServletContextListener MessageListener（消息队列接口）
~~~









# day 05

## 5.1简答题

41、实现开闭原则有哪几种方式

~~~
软件实体应当对扩展开放，对修改关闭，也就是：软件系统中包含的各种组件，例如模块（Modules）、类（Classes）以及功能（Functions）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的，即不应该修改原有的代码。

对扩展开放 ——- 模块的行为可以被扩展从而满足新的需求。
对修改关闭 ——- 不需要修改模块的源代码。（或者尽量使修改最小化）
怎样实现开闭原则

抽象
多态
继承
接口
~~~



42、jdk动态代理与cglib动态代理的区别，

~~~
jdk动态代理	
需要有顶层接口才能使用，但是在只有顶层接口的时候也可以使用，常见是mybatis的mapper文件是代理。
使用反射完成。使用了动态生成字节码技术。

cglib动态代理	可以直接代理类，使用字节码技术，不能对 final类进行继承。使用了动态生成字节码技术。
~~~



43、什么是切面，连接点，通知，织入

~~~
切面： 
定义：切面是通知和切点的集合，通知和切点共同定义了切面的全部功能——它是什么，在何时何处完成其功能。

连接点： 
定义：连接点是一个应用执行过程中能够插入一个切面的点。

通知： 
定义：切面也需要完成工作。在 AOP 术语中，切面的工作被称为通知。

织入： 
织入是将切面应用到目标对象来创建的代理对象过程。

切点： 
定义：如果通知定义了“什么”和“何时”。那么切点就定义了“何处”。切点会匹配通知所要织入的一个或者多个连接点。
~~~



44、aop通知有几种类型，around有什么特殊之处 

~~~
Before——在方法调用之前调用通知
After——在方法完成之后调用通知，无论方法执行成功与否
After-returning——在方法执行成功之后调用通知
After-throwing——在方法抛出异常后进行通知
Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为

ProceedingJoinPoint
~~~



45、pom.xml中有哪些重要的标签，作用是什么

~~~xml
 <!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。-->  
    <parent>  
        <!--被继承的父项目的构件标识符-->  
        <artifactId/>  
        <!--被继承的父项目的全球唯一标识符-->  
        <groupId/>  
        <!--被继承的父项目的版本-->  
        <version/>  
        <!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。-->  
        <relativePath/>  
    </parent>  
    <!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。-->  
    <modelVersion>4.0.0</modelVersion>  
    <!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app-->  
    <groupId>asia.banseon</groupId>  
    <!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。-->  
    <artifactId>banseon-maven2</artifactId>  
    <!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型-->  
    <packaging>jar</packaging>  
    <!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号-->  
    <version>1.0-SNAPSHOT</version>  
~~~



46、clean  compile package install分别有什么效果

~~~
clean： 执行该命令会删除项目路径下的target文件，但是不会删除本地的maven仓库已经生成的jar文件

compile：编译命令，只编译选定的目标，不管之前是否已经编译过，会在你的项目路径下生成一个target目录，在该目录中包含一个classes文件夹，里面全是生成的class文件及字节码文件。

package：这个命令会在你的项目路径下一个target目录，并且拥有compile命令的功能进行编译，同时会在target目录下生成项目的jar/war文件。如果a项目依赖于b项目，打包b项目时，只会打包到b项目下target下，编译a项目时就会报错，因为找不到所依赖的b项目，说明a项目在本地仓库是没有找到它所依赖的b项目，这时就用到install命令了

install：该命令包含了package命令功能，不但会在项目路径下生成class文件和jar包，同时会在你的本地maven仓库生成jar文件，供其他项目使用（如果没有设置过maven本地仓库，一般在用户/.m2目录下。如果a项目依赖于b项目，那么install b项目时，会在本地仓库同时生成pom文件和jar文件，解决了上面打包package出错的问题）
build：功能类似compile，只是只对整个项目进行编译
~~~



47、自定义注解需要依赖哪些元注解

~~~java
@Retention 保留期，能设定注解的存活时间

RententionPolicy:SOURCE 源代码阶段

RententionPolicy:CLASS 到编译阶段

RententionPolicy:RUNTIME 到运行阶段

eg: 

@Rentention(RententionPolicy:RUNTIME)
public @interface Xxx{}
 

@Documented

将注解中的元素包含到Javadoc中

 

@Target

限定注解能运用的地方

ElementType.ANNOTATION_TYPE 注解

ElementType.COUNSTRUCTOR 构造方法

ElementType.FIELD 属性



@Inherited

标明注解是能被继承的，例如B继承了A，A添加了注解，那么B也会继承同样的注解
~~~



48、如何理解所有配置、标签最后都是java代码

~~~
Java通过DOM4J或其他xml解析技术，解析xml中配置的信息，通过反射或其他方式将信息生成对应的参数或类对象
~~~



49、toString, wait, nofify, notifyAll, sleep, equeals, hashCode属于哪些类

~~~java
toString, wait, nofify, notifyAll, equeals, hashCode   //Object

sleep //Thread
~~~



50、String s="123";		String s1=new String("123");		String s2="123";

​    s.equals(s1)=?	s==s1 ?		s==s2  ?

~~~java
s==s2   s.equals(s1)  s!=s2
~~~



## 5.2 编程题



## 5.3 课堂内容

### 5.3.1  springmc注解配置

~~~xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <!--这个servlet是子容器，在tomcat启动之时会被加载【配置了load-on-startup,否则，用的时候才加载】，主要用来加载mvc模块。
    init-param是此servlet加载所要依赖的文件，会被getInitParameter获取，进而加载解析，通过反射获取所有标签所代表的类的对象
    从而完成MVC。
    这个servlet就是前端控制器【中央控制器】：接收请求，转发请求；
  -->
  <servlet>
    <servlet-name>mvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>mvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
~~~

~~~xml
    <!--这是子容器加载所以来的配置文件-->


    <!--扫描路径约束了子容器究竟加载哪些类【类的上面要有标记Component, Controller, Service, Reponsitory】-->
    <context:component-scan base-package="net.wanho.controller"></context:component-scan>

    <!--此标签后面是两个东西的加载：处理器映射器【找到对应的controller】、处理器适配器【找到对应的api】,响应数据的返回在此处也会进行转化-->
    <mvc:annotation-driven></mvc:annotation-driven>


    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>

~~~



### 5.3.2 restful

~~~java
	@RequestMapping(value = "/{id}/{name}",method = RequestMethod.POST)
    @ResponseBody
    public JSONObject add(@PathVariable("id") int id, @PathVariable("name") String name)
    {
        JSONObject jsonObject = new JSONObject();
        return jsonObject;
    }

	@RequestMapping(value = "/{id}",method = RequestMethod.DELETE)
    @ResponseBody
    public JSONObject delete(@PathVariable("id") int id)
    {
        JSONObject jsonObject = new JSONObject();
        return jsonObject;
    }

    @RequestMapping(value = "/{id}/{name}",method = RequestMethod.PUT)
    @ResponseBody
    public JSONObject update(@PathVariable("id") int it,@PathVariable("name") String name)
    {
        JSONObject jsonObject = new JSONObject();
        return jsonObject;
    }

    @RequestMapping(value = "/",method = RequestMethod.GET)
    @ResponseBody
    public JSONObject select()
    {
        JSONObject jsonObject = new JSONObject();
        return jsonObject;
    }
~~~



### 5.3.3  参数传递

~~~java
1.直接在参数上加javabean提供空参构造和get set方法 传递过来的参数和成员变量名对应即可
2.在参数前面加上@RequestParam（"name"）如
        @RequestMapping("test1")
        @ResponseBody
        public String test(@RequestParam("name")String name,@RequestParam("id")int id){
            System.out.println(name);
            System.out.println(id);
            return "name:"+name+"id:"+id;
        }
        
3.在参数前加上@PathVariable("id") 如 
 		@RequestMapping(value = "/{id}/{name}",method = RequestMethod.POST)
        @ResponseBody
        public JSONObject add(@PathVariable("id") int id, @PathVariable("name") String name)
        {
            JSONObject jsonObject = new JSONObject();
            return jsonObject;
        }

注意 如果参数是一个对象类型 成员属性名和路径的{id} id名一样 那么不需要加@PathVariable 会自动赋值进去
    @RequestMapping(value="/student/add/{name}",method = RequestMethod.GET)
    @ResponseBody
    public JSONObject addStudent(Student student)
    {
        JSONObject ret = new JSONObject();
        try {
            studentService.addStudent(student);
            ret.put("status",200);
            ret.put("msg","add success:"+student.getId());
        }
        catch(Exception e)
        {
            ret.put("status",100);
            ret.put("msg","add error");
            e.printStackTrace();
        }
        return ret;
    }
 
 (以下了解)
 4. 前台传递过来的参数名和方法形参的名字一一对应 但是必须包含所有对应的参数（和第二个一样 但是第二个加上注解可以让传递过来的参数名和形参名不一样）
    @RequestMapping("/test1")
    @ResponseBody
    public String test1(int id,String name,int ret)
    {
        return "success";
    }

5.在形参前加上@RequestHeader("name")  可以直接获取请求头里key为name的参数如
    @RequestMapping("/test2")
    @ResponseBody
    public String test2(@RequestHeader("name")String name)
    {
        return "success";
    }

6.  在形参前加上@CookieValue 可以直接获得cookie中的参数 根据name来获取
    @RequestMapping("/test3")
    @ResponseBody
    public String test3(@CookieValue("name")String name)
    {
        return "success";
    }
~~~





### 5.3.4 返回类型

~~~java
1.//加上 @ResponseBody 相当于response.getWriter().write（）；可以返还JSONObject和任何类型
	@RequestMapping("/test1")
    @ResponseBody
    public String test1(int id,String name,int ret)
    {
        return "success";
    }
   
2.//不加任何注解，返还String默认会去查找视图解析器。
	@RequestMapping("/tosuccess2")
    public String test6()
    {
        return "success";
    }
 
 3.//返还String，加上forward:默认请求转发，如果类上面也有@RequestMapping，那么转发的路径上默认会加上类上的路径
 	@RequestMapping("/tosuccess2")
    public String test6()
    {
        return "forward:success1.jsp";
    }

4.//返还String，加上redirect:默认重定向，如果类上面也有@RequestMapping，那么转发的路径上默认会加上类上的路径
    @RequestMapping("/tosuccess3")
    public String test7()
    {
        return "redirect:success1.jsp";
    }

5.//ModelAndView创建对象时配置的字符串会自动匹配视图解析器，可以addObject，来向request域中添加对象 返回时要将该对象返还
	@RequestMapping("/test4")
    public ModelAndView test4()
    {
        ModelAndView modelAndView = new ModelAndView("success");
        modelAndView.addObject("name","ali");
        Map<String,String> map = new HashMap<>();
        map.put("age","18");
        map.put("sex","nan");
        modelAndView.addAllObjects(map);
        return modelAndView;
    }

6.//参数中提供Map或者ModelMap 可以在返还时向request中设置参数
    @RequestMapping("/test5")
    public String test5(Map<String,String> map)
    {
        map.put("name","ali");
        return "success";
    }

    @RequestMapping("/test6")
    public String test6(ModelMap map)
    {
        map.put("name","ali");
        return "success";
    }
~~~





### 5.3.5 springmvc配置配置

方法一

~~~xml
  <!-- 处理器映射器，将bean的name作为url进行查找，访问路径就是： http://127.0.0.1:8080/userController
    console界面打印日志最关键部分：-->
 <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"></bean>
    <bean id="/userController" class="net.wanho.controller.UserController">
        <property name="userManager" ref="userManager"></property>
    </bean>


~~~

方法二

~~~xml
<!-- 处理器映射器，可以自定义url，这是为入口类提供了一个别名，保证了访问者无法知悉类的名字，访问路径是：http://127.0.0.1:8080/hello2 -->
    <bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="mappings">
            <props>
                <prop key="/hello2">userController</prop>
            </props>
        </property>
    </bean>

    <bean id="userController" class="net.wanho.controller.UserController">
    </bean>
~~~

方法三

~~~xml
 <!--根据类名前缀和方法名称进入，因为以上2种方式都只能是一个类对应一个接口，所以便有了这个类，可以在一个类中包含多个api
        访问路径是：http://127.0.0.1:8080/student/test
        特别要注意的是：自己定义的方法包含两个参数，如
        public String test(HttpServletRequest request，HttpServletResponse response){}
    -->
   <bean
            class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping">
    </bean>
    <bean id="studentController" class="net.wanho.controller.StudentController" scope="prototype">
    </bean>
~~~



MultiActionController 类 继承

Controller 接口 实现

### 5.3.6 页面无法访问静态资源

~~~xml
<!--在springmvc配置文件中配置下行代码-->
<mvc:default-servlet-handler />
~~~





### 5.3.7  svn使用



### 5.3.8 git使用

~~~
项目创建流程视频6-1
1．	安装nodejs （会自动安装npm）在nodejs官网下载 下载长期维护的版本即可
2．	将本地代码和git账户绑定
3．	将线上仓库里创建的项目复制ssh链接，之后打开shell或者gitbash在命令行输入
先cd desktop 进入桌面
git clone xxxxxxxx/复制的地址---xxx为复制的ssh链接 复制的地址为你要放进桌面的哪个文件夹内 没有文件夹会自动创建
4.此时桌面上就会多出你的项目文件夹
5.安装vue.cli脚手架工具
5.1.打开shell或者gitbash 输入 npm install –global vue—cli   这是全局安装
5.2.切换到桌面 cd desktop
5.3.vue init webpack Travel 创建webpack项目 并把项目放进桌面的Travel文件夹下
5.4回车后会询问你项目文件夹已存在 是否继续 选择确定
5.5.之后会出现一系列的选项：
5.5.1.项目的名称 不能包含大写字母
5.5.2.项目的描述 直接回车
5.5.3.作者的名字 自定
5.5.4.采用项目的编译形式 第一个是运行时编译 第二个是运行时和普通情况下编译 选择第一个
5.5.5.是否安装vue router 选择是
5.5.6.编码时是否使用ESLint检查代码的工整度 选择是
5.5.7.选择代码监测规范 选择standard
5.5.8.是否使用自动化测试 选择no
5.5.9.是否使用e2e端到端的测试 选择no
5.5.0.使用那种包管理 选择npm包管理
6.进入桌面的Travel文件夹 运行npm run dev命令 会自动启动项目 
7.退出服务器 在travel目录下执行git status命令 可以看到本地仓库多出来很多文件
8.git add . 将多出的文件添加到本地的缓冲区
9.git commit -m project_init 
10.git push 将本地代码提交到线上仓库


5.	创建分支
5.1.	在实际的项目开发之中，每加入一个新的功能，其实就是创建一个新的分支
5.2.	打开码云官网 上面有个我的码云 进入之后点击该项目 之后有个分支，点击
5.3.	左上角新建分支 分支名index-swiper 点击创建分支 线上的分支就创建好了
5.4.	之后需要将线上的分支拉到本地来
5.5.	进入shell 切换到项目路径 输入命令 git pull这时候线上的分支就会拉到本地
5.6.	执行 git checkout index-swiper 切换本地的分支到刚刚创建的分支
5.7.	执行git status 可以查看当前本地所在的分支
5.8.	之后开发代码都会在这个分支上进行开发
5.9.	执行npm run start 启动项目

将该功能提交到线上的分支，并且将分支合并到master上
git add .
git commit -m change
git push
git checkout master 先切换到master分支上
git merge origin/index-swiper 将线上index-swiper分支上的内容合并到master分支
git push 将合并后的master也提交到线上

8.	首页图标开发
8.1首先需要在码云上新建一个index-icons的分支
8.1.1.	左上角新建分支 分支名index-icons点击创建分支 线上的分支就创建好了
8.1.2.	之后需要将线上的分支拉到本地来
8.1.3.	进入shell 切换到项目路径 输入命令 git pull这时候线上的分支就会拉到本地
8.1.4.	执行 git checkout index-icons 切换本地的分支到刚刚创建的分支
8.1.5.	执行git status 可以查看当前本地所在的分支
8.1.6.	之后开发代码都会在这个分支上进行开发
8.1.7.	执行npm run start 启动项目

Git add .
Git commit -m add_icons
Git push

合并线上的master分支
Git checkout master
Git merge origin/index-icons
Git push

如果线下代码改动没有上传到git，但是又要下载新的分支，就会报错。
这时需要
Git checkout .可以去除这次更改
Git branch 查看一下
Git merge index-recommond  让现在的分支和之前没有合并的分支做一个合并
Npm run dev即可

~~~







# day 06

## 6.1 简单题

41、什么是前端控制器、处理器映射器、处理器适配器、视图解析器以及Handle

~~~
前端控制器DispatcherServlet处理所有从用户过来的请求。所有用户的请求都要通过前端控制器，只有在得到控制器验证后，被前端控制器重新定向才可以访问相应的资源。

处理器映射器、处理器适配器:处理器映射器，顾名思义是获取映射关系的一个东西，那么结合上下文其实就是url和对应处理函数的关系，然后是handleradapter，有了映射关系还要进一步去找到调用这个处理函数才行啊，那么这个handleradapter就是去调用具体处理函数的

视图解析器:将返回的逻辑视图解析成真正的地址。

Handle 就是@RequestMapping下映射的方法

~~~



42、springmvc当中配置的三个常用的处理器映射器是什么

~~~
BeanNameUrlHandlerMapping
SimpleUrlHandlerMapping
ControllerClassNameHandlerMapping
~~~



43、springmvc当中静态资源如何处理

~~~xml
<mvc:default-servlet-handler />
<!--资源映射 当视图解析器没有找到路径时 会匹配这个路径-->
<mvc:resources mapping="/**" location="/"></mvc:resources>

~~~



44、@RequestParam/@RequestHeader/@CookieValues/@PathViriable分别是做什么的

~~~
自动装配前端传来的参数/自动获得header中对应的值/自动获得cookie中的值/获得requestMapping中的值
~~~



45、线程的实现方式有哪些

46、域名、ip、DNS、端口的作用是什么

~~~
1.域名（Domain Name）
域名是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称， 
用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。 
域名是一个IP地址上的“面具” 。一个域名的目的是便于记忆和沟通的一组服务器的地址（网站，电子邮件，FTP等）。 
域名作为力所能及难忘的互联网参与者的名称。

2.DNS即为域名解析服务。 
域名解析器，是把域名转换成主机所在IP地址的中介。通常上网的时候，敲入一个域名地址， 
电脑会首先向DNS服务器搜索相对应的IP地址，服务器找到对应值之后，会把IP地址返回给你的浏览器，这时浏览器根据这个IP地址发出浏览请求，这样才完成了域名寻址的过程。 
操作系统会把你常用的域名IP地址对应值保存起来，当你浏览经常光顾的网站时，就可以直接从系统的DNS缓存里提取对应的IP地址，加快连线网站的速度。

2.端口
端口详解
端口是指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。
~~~



47、获得Class对象的方式有哪些

~~~
Class.forname("全路径")
类名.class
对象.getClass();
~~~



48、分页的关键是什么

~~~
Mysql limit
oracle rownum
~~~



49、数据库当中floor, ceil , round, trunc分别是干什么的

~~~
向下取整
向上取整
四舍五入
截取
~~~



50、你为什么离职、上家公司叫什么、在哪里、老板叫什么、主要做什么、你负责什么

~~~

~~~





## 6.2 编程题





## 6.3 课堂内容



### 6.3.0 三个接口

~~~
DateTimeFormat
PropertyEdit （Support）
Converter
~~~



### 6.3.1 静态资源访问

~~~xml
    <!--<mvc:default-servlet-handler />-->
    <!--资源映射 当视图解析器没有找到路径时 会匹配这个路径 一般舒勇下面的-->
    <mvc:resources mapping="/**" location="/"></mvc:resources>
~~~

### 6.3.2 错误代码404等进error页面

~~~xml
<!--在web.xml中配置-->
  <error-page>
        <error-code>404</error-code>
        <location>/404.jsp</location>
    </error-page>
    <error-page>
        <error-code>500</error-code>
        <location>/404.jsp</location>
    </error-page>
~~~



### 6.3.3 @ModelAttribute  @SessionAttributes

~~~java
   //这个是request级别的 初始化只会在一次request中期作用 并且初始化必须与要被初始化的handler在同一个类中
	@ModelAttribute
    public void initUser(User user)
    {
       user.setName("aaa");
    }


    @RequestMapping("/usera")
    public String usera(User user)
    {
        return "attribute";
    }
~~~

~~~java
//这个是Session级别的 即访问这个类中的Handler后 只要给Map赋值  那么Map中的值也能在别的地方使用
@Controller
@RequestMapping("/student")
@SessionAttributes(value = "USER")
public class StudentController {
    //这个是需要使用的地方
	@RequestMapping("/testsession")
    public String test4(Map map)
    {
        return "attribute";
    }
 }


@Controller
@SessionAttributes(value = "USER")
public class AttributeController {
    //这个是给map赋值的地方
    @RequestMapping("/login")
    public String login(User user, Map map)
    {

        boolean isOk = true;//模拟验证成功
        if(isOk)
        {
            map.put("USER","ali");
        }
        return "attribute";
    }
}
~~~



### 6.3.4 国际化

~~~xml
    <!--==============================国际化===============================-->
<!--还需要两个配置文件-->
    <!-- 存储区域设置信息 -->
    <bean id="localeResolver"
          class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/>
    <!-- 国际化资源文件 -->
    <bean id="messageSource"
          class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
        <property name="basename" value="classpath:messages"/>
    </bean>
    <mvc:interceptors>
        <bean id="localeChangeInterceptor"
              class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
            <property name="paramName" value="lang"/>
        </bean>
    </mvc:interceptors>

~~~

~~~jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
         pageEncoding="UTF-8" %>
<%@taglib prefix="mvc" uri="http://www.springframework.org/tags/form" %>
<%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<html>
<head>
    <title>SpringMVC<spring:message code="internationalisation"/></title>
</head>
<body>
    <spring:message code="welcome"/>
</body>
</html>
~~~



### 6.3.5 文件上传和下载

#### 6.3.5.1 文件上传 

~~~xml
 <!--==================================文件上传======================================-->
<!--可能还需要commons的jar包-->
    <bean id="multipartResolver"
          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        <property name="defaultEncoding" value="UTF-8"></property>
        <property name="maxUploadSize" value="1024000"></property>
    </bean>
    
    
~~~

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>


<form action="testFileUpload" method="POST" enctype="multipart/form-data">
    File: <input type="file" name="file"/>
    Desc: <input type="text" name="desc"/>
    <input type="submit" value="Submit"/>
</form>

</body>
</html>
~~~

~~~java
@Controller
public class FileUploadController {

    @RequestMapping("/testFileUpload")
    public String testFileUpload(HttpServletRequest request, @RequestParam("desc") String desc,
                                 @RequestParam("file") MultipartFile file) throws IOException {
        System.out.println("desc: " + desc);
        System.out.println("OriginalFilename: " + file.getOriginalFilename());
        System.out.println("InputStream: " + file.getInputStream());
        String filePath = request.getSession().getServletContext()
                .getRealPath("/") + file.getOriginalFilename();
        file.transferTo(new File(filePath));
        return "success";
    }
 }
~~~



#### 6.3.5.2文件下载

~~~java
 @RequestMapping(value = "/DownloadFile")
    public ResponseEntity<byte[]> DownloadFile(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //  接受的是UTF-8
        req.setCharacterEncoding("utf-8");
        //获取项目根目录
        String path = "C:\\Users\\Administrator\\Desktop\\123.txt";
        //获取文件名
        String filename = "1.txt";
        File file = null;
        HttpHeaders headers = null;
        
        try {

            System.out.println(filename);//myfiles

            file = new File(path);

            //请求头

            headers = new HttpHeaders();

            String fileName1 = new String(filename.getBytes("UTF-8"), "iso-8859-1");//解决文件名乱码

            //通知浏览器以attachment（下载方式）打开图片
            headers.setContentDispositionFormData("attachment", fileName1);

            //application/octet-stream二进制流数据（最常见的文件下载）。
            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);

        } catch (Exception e) {

            throw new RuntimeException(e);

        }

        return new ResponseEntity<byte[]>(FileUtils.readFileToByteArray(file), headers, HttpStatus.OK);
    }
~~~



### 6.3.6 @DateTimeFormat（pattern="yyyy-MM-dd"）

~~~java
//这个注解给javaBean里面的Date格式的属性加上
~~~



### 6.3.7 类型转换--当前处理器（Handler）

~~~java
//这个写在哪个RequestMapping类中 只有这个类中会生效
//记住PropertyEditor接口  PropertyEditorSupport
@InitBinder
    protected void initBinder(WebDataBinder binder) {
        //这个方法定义了当参数类型是什么的时候调用转换器  比如当User的createTiem是date类型 
        //由于传递过来的的参数都是String类型 所以会调用这个转换器进行转换
        binder.registerCustomEditor(Date.class, new MyDateEditor());
        binder.registerCustomEditor(net.wanho.entity.Telphone.class,new MyPhone());
    }

    private class MyDateEditor extends PropertyEditorSupport {
        @Override
        public void setAsText(String text) throws IllegalArgumentException {
            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date date = null;
            try {
                date = format.parse(text);
            } catch (ParseException e) {
                format = new SimpleDateFormat("yyyy-MM-dd");
                try {
                    date = format.parse(text);
                } catch (ParseException e1) {
                }
            }
            setValue(date);
        }
    }
~~~





### 6.3.8 类型转换--所有处理器（Handler）

~~~
实现Converter<S,T>类

~~~





### 6.3.9 校验

~~~java
    @RequestMapping("/foo")
    public ModelAndView foo(@Valid Foo foo , BindingResult bindingResult) {
        List<String> errorList = new ArrayList<>();
        if(bindingResult.hasErrors()){
            for (FieldError fieldError : bindingResult.getFieldErrors()) {
                errorList.add(fieldError.getDefaultMessage());
            }
            ModelAndView modelAndView = new ModelAndView("fail");
            modelAndView.addObject("error",errorList);
            return modelAndView;
        }
        return new ModelAndView("success");
    }
~~~

~~~java
public class Foo {

    @NotBlank
    private String name;

    @Min(18)
    private Integer age;

    @Pattern(regexp = "^1(3|4|5|7|8)\\d{9}$",message = "手机号码格式错误")
    @NotBlank(message = "手机号码不能为空")
    private String phone;

    @Email(message = "邮箱格式错误")
    private String email;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
~~~



~~~jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
         pageEncoding="UTF-8"%>
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Insert title here</title>
</head>
<body>
<form:form modelAttribute="user" action="${pageContext.request.contextPath}/saveUser" >
    用户名：<form:input path="username"/><br/>
    密码：<form:input path="password"/><br/>
    性别：<form:radiobutton path="gender" value="男" label="男"/><form:radiobutton path="gender" value="女" label="女"/><br/>
    <%--手机操作系统：<form:radiobuttons path="mobilesys" items="${allmobilesys}" /><br/>--%>
    是否同意此协议：<form:checkbox path="agree"/><br/>
    技能：
    <form:checkbox path="telcols" value="画画" label="画画"/>
    <form:checkbox path="telcols" value="游泳" label="游泳"/>
    <form:checkbox path="telcols" value="编程" label="编程"/>
    <form:checkbox path="telcols" value="足球" label="足球"/>
    <br/>
    <!--
    items：数据源，以集合的el表达式描述
    itemLabel：设置那个属性作为显示文本
    itemValue：设置选中的值
    -->
    <%--拥有的车型：<form:checkboxes items="${allCarList}" path="carlist" itemLabel="brand" /><br/>--%>
    来自那个国家：<form:select path="country">
    <%-- <form:option value="中国">中国</form:option>
    <form:option value="美国">美国</form:option>
    <form:option value="韩国">韩国</form:option> --%>
    <form:options items="${allCountry}" />
</form:select><br/>
    <input type="submit" value="提交"/>
    <form:errors path="*" cssStyle="color: darkred"></form:errors>
</form:form>
</body>
</html>
~~~





# day 07

## 7.1 简答题

61、springmvc当中数据类型的转化有哪三个接口

~~~
@DateTimeFormat Converter PorpertyEditor(PropertyEditSupport)
~~~



62、springmvc当中数据的格式化有哪四个接口

~~~
Parser Formatter Printer AnnotationFormatterFactory
~~~



63、@InitBinder、PropertyEditorSupport、setAsText、DateTimeFormat、Controller、MultiActionController、BeanNameurlHandleMapping、SimpleurlHandleMapping、ControllerBeanNameHandleMapping是干什么的

~~~
@InitBinder、PropertyEditorSupport、setAsText：@InitBinder进行数据的转换 配置后只能在该Controller中起作用 PropertyEditorSupport是@InitBinder中进行注册的转换方法的实现类 setAsText是PropertyEditorSupport中的重写方法 里面编写具体转换的业务逻辑

Controller、MultiActionController是配置实现SpringMVC的接口 实现之后可以通过配置来完成mvc的访问

springmvc配置配置 BeanNameurlHandleMapping、SimpleurlHandleMapping、ControllerBeanNameHandleMapping
~~~



64、程序、进程、线程的概念是什么

~~~
程序是算法+结构
进程是资源分配的单位
线程是资源执行和调度的单位
~~~



65、校验数据的技术有哪些

~~~
JSR 303 规范
Hibernate Validator 实现并扩展JSR 303
~~~



66、编程规范是什么

~~~
命名规范 驼峰模式

编码规范 可维护性 高内聚 低耦合
~~~



67、处理post请求乱码的三种方式是什么、响应有乱码如何处理

~~~
request.setCharacterEncoding("utf-8")
new String(request.getParamter("").getBytes("iso-8859-1"),"utf-8")
配置spring的乱码过滤器
~~~



68、3306、1521、80、8080、 21、 22、6379各是什么端口；404、500指的是什么；

~~~
3306：mysql
80：http
8080：tomcat/Jboss
21：ftp
22：ssh
6379：redis
Oracle：1521

404：是后端服务器的资源不存在
500：是服务器异常
~~~



69、linux中vi cd pwd dir ls ifconfig mkdir touch cat whoami命令是什么作用

~~~
vi:编辑文本
cd：切换路径
pwd：当前路径
dir：当前目录
ls：显示当前目录下所有文件
ifconfig：查看网络配置
mkdir:创建目录
touch：创建文件
cat:查看文件额呢绒
whoami：查看当前登陆用户
~~~



70、ddl语句、dcl语句有哪些

~~~
3. 数据定义语言DDL
数据定义语言DDL用来创建数据库中的各种对象-----表、视图、
索引、同义词、聚簇等如：
CREATE TABLE/VIEW/INDEX/SYN/CLUSTER
| | | | |
表 视图 索引 同义词 簇

DDL操作是隐性提交的！不能rollback 

4. 数据控制语言DCL
数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制
数据库操纵事务发生的时间及效果，对数据库实行监视等。如：
1) GRANT：授权。


2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。
回滚---ROLLBACK
回滚命令使数据库状态回到上次最后提交的状态。其格式为：
SQL>ROLLBACK;


3) COMMIT [WORK]：提交。
~~~



## 7.3 课堂内容



### 7.3.1 解决乱码

~~~jsp
jsp页面内容本身乱码：<%@ page contentType="text/html;charset=UTF-8" language="java" %>
html页面内容本身乱码：<meta charset="UTF-8">

web.xml中配置spring自带过滤器
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <!-- 配置encoding，告诉我们指定的编码格式 -->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
        <!-- 解决响应乱码 -->
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

tomcat server.xml中
<Connector></Connector>添加属性 URIEncoding="UTF-8" <!--解决POST-->
~~~





### 7.3.2 SpringMVC异常处理

~~~
web.xml中配置error-page
~~~

~~~xml
   <!--在springmvc.xml中配置 发现异常会查询视图解析器-->
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>

	
    <bean id="simpleMappingExceptionResolver" class=
            "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <map>
                <!-- key:异常类别（非全称), 视图名称 -->
                <entry key="ArithmeticException" value="arithmetic"/>
            </map>
        </property>
        <!-- 如果在以上配置中找不到异常，则进入此默认异常 -->
        <property name="defaultErrorView" value="error"/>
    </bean>
~~~

~~~java
//编写一个处理全局异常的类 加上@ControllerAdvice  
//方法上加上  @ExceptionHandler(value = ArithmeticException.class)
//应该需要在springmvc中扫描这个包

@ControllerAdvice
public class ExceptionHandle {
    @ExceptionHandler(value = ArithmeticException.class)
    public String test1excp()
    {
        System.out.println(this);
        return "arithmetic";
    }

    @ExceptionHandler(value = NullPointerException.class)
    public String test2excp()
    {
        return "error";
    }
}


~~~

~~~java
 //如果单独把这个写在Controller中 那么只有在这个controller出现异常时才会生效
 @ExceptionHandler(value = NullPointerException.class)
    public String test2excp()
    {
        return "error";
    }
~~~



### 7.3.3 拦截器

~~~xml
    <!--拦截器，拦截path路径到class
		拦截器只会拦截Action  不会拦截jsp和静态资源
	如果有两个拦截器 会按顺序执行 但如果有一个拦截后 跳转页面 不会再进入拦截器 因为只能对Action进行拦截
	拦截器是sprignmvc内部的 而springmvc的入口是DisptacherServlet 因此进入拦截器之前 必定会进入这个Servlet 而进入Servlet之前必定会进入Filter 因此Filter必定在Intecepter之前执行
-->
  <mvc:interceptors>
        <mvc:interceptor>
            <mvc:mapping path="/*"/>
            <bean class="net.wanho.system.LoginIntecepterHandle"></bean>
        </mvc:interceptor>
        <mvc:interceptor>
            <mvc:mapping path="/*"/>
            <bean class="net.wanho.system.LoginIntecepterHandle2"></bean>
        </mvc:interceptor>
    </mvc:interceptors>
~~~

~~~java
public class LoginIntecepterHandle implements HandlerInterceptor {


    //api执行之前
    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        System.out.println("preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)");


        Object object = httpServletRequest.getSession().getAttribute("user");

        if(object==null)
        {
            httpServletResponse.sendRedirect("/login.jsp");
            return false;
        }


        return true;
    }

    //api执行之后，页面渲染之前
    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)");
    }

    //api执行之后，页面渲染之后
    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
        System.out.println("afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)");
    }

~~~



### 7.3.4 自定义视图

~~~xml
   <!--在springmvc中配置这个 并且扫描需要扫描到下面的类 这样会把类名当作视图返还的路径 类名首字母小写
		order代表优先级 会和   <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>配置的优先级进行比较 

-->
<bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
        <property name="order" value="100"></property>
    </bean>

~~~



~~~java
@Component
public class HelloView implements View {
    @Override
    public String getContentType() {
        return "text/html";
    }

    @Override
    public void render(Map<String, ?> model, HttpServletRequest request,
                       HttpServletResponse response) throws Exception {
        response.getWriter().print("hello view, time: " + new Date());
    }
}

~~~



### 7.3.5 httpClient 可以进行压力测试



### 7.3.6 json格式的转换

~~~xml
<!--spring 4.2.x以后的版本返回json格式会出现异常 需要在<mvc:annotation-driven >中配置-->
    <mvc:annotation-driven>
        <mvc:message-converters register-defaults="false">
            <!-- 避免IE执行AJAX时,返回JSON出现下载文件 -->
            <bean id="fastJsonHttpMessageConverter" class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter">
                <property name="supportedMediaTypes">
                    <list>
                        <!-- 这里顺序不能反，一定先写text/html,不然ie下出现下载提示 -->
                        <value>text/html;charset=UTF-8</value>
                        <value>application/json;charset=UTF-8</value>
                    </list>
                </property>
            </bean>
        </mvc:message-converters>
    </mvc:annotation-driven>


<!--RestController=Controller+ResponseBody 直接注解在controller类上不需要再注解@ResponseBody
~~~

### 7.3.7 父子容器 及事务

~~~java
由于系统启动之时，加载顺序如何：listener[servletcontextlistener]、filter、servlet[load-on-startup]
可以看出在Web.xml中配置的下面的父容器的org.springframework.web.context.ContextLoaderListener会先加载
因为该类的源码是实现了servletcontextlistener接口的因此在tomcat启动之时必定会第一个创建 然后内部进行父容器的初始化
子容器之后会在springmvc配置文件加载时创建由于springmvc配置文件时在DispatcherServlet加载时进行加载的
因此Controller会在父容器创建之后创建
父容器先创建 里面对应的beans也是先创建 因此如果配置事务在子容器，父容器是无法访问子容器中的内容

//如果在父容器中进行了事务的配置 并扫描了service层，而子容器中没有进行事务的配置 但也扫描的service层,那么springmvc中生成的controller里面注入的service是子容器扫描到的没有事务的service。因此springmvc只扫描springmvc的内容 其他的都由父容器ContextLoaderListener扫描


//将事务和service扫描配置在父容器中，子容器也扫描service
//之后子容器有service 父容器也有service 但是启动事务注解的时候是在父容器配置的<tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>，这时候启动只能再父容器中生成有事务的service代理类 当子容器加载时aop事务已经结束 而子容器也扫描了service 所以子容器中的controller注入的就是子容器中没有事务的service

~~~



~~~xml
  <!--父容器先加载，子容器后加载；子容器能访问父容器，父容器不能访问子容器；父容器加载ServletContext，子容器加载MVC
    最好分开在多个xml中加载，因为可以解耦合

    只有经过父容器强化的事务才是有效的：事务必须在父容器【父子容器同时存在，父容器加载的事务是有效的】
  -->

  父容器
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext-*.xml</param-value>
  </context-param>
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>


  <!--子容器
      子容器可以访问父容器，但父容器不能访问子容器
      子容器中不能加载外部资源标签<context:property-placeholder location="jdbc.properties"></context:property-placeholder>
  -->
  <servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>

    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

~~~



# day 08

## 8.1 简单题

71.converter，propertyEditor,factoryBean,methodInterceptor,InvocationHandle,Controller分别是做什么

~~~
converter，pripertyEditor是springmvc进行数据类型转换
factorybean是spring实现工厂方式来获得bean
methodInterceptor Cglib实现动态代理
InvocationHandle是JDK动态代理的接口
Controller是实现springmvc配置方式的接口
~~~

72.解释高内聚，低耦合；由粗到细自顶而下

~~~
耦合性称为：块间联系

指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。

内聚性称为：块内联系

指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。


结构化设计方法的实现要点 由粗到细 逐层分解 自顶而下 逐步求精
~~~

73、解释数据库中的笛卡尔乘积、垂直过滤、水平过滤

~~~
笛卡尔乘积是表与表之间连接时没有条件 那么就会形成AXB条数据
1，水平分割：

例：QQ的登录表。假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1...qq99表。

用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。

这就是水平分割。

 

2，垂直分割：

垂直分割指的是：表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。

例如学生答题表tt：有如下字段：

Id name 分数 题目 回答

其中题目和回答是比较大的字段，id name 分数比较小。

如果我们只想查询id为8的学生的分数：select 分数 from tt where id = 8;虽然知识查询分数，但是题目和回答这两个大字段也是要被扫描的，很消耗性能。但是我们只关心分数，并不想查询题目和回答。这就可以使用垂直分割。我们可以把题目单独放到一张表中，通过id与tt表建立一对一的关系，同样将回答单独放到一张表中。这样我们插叙tt中的分数的时候就不会扫描题目和回答了。
~~~



74、截至目前，我们学过了哪些数据固化组件

~~~
oracle mysql redis 
~~~



75、主键有什么特性、各代表什么意思

~~~
非空 唯一
不能为空 值唯一
~~~



76、MVC  AOP	OOP	DI	IOC		CAP		ACID	DML	DQL		HTTP

TCP		IP		DNS		CDN	SSO	SSM	SSH

~~~
model-view-controller 面向切面编程 面向对象 依赖注入 控制反转 
CAP Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）
ACID 指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
DML 数据操纵语言
DQL数据查询语言
HTTP 超文本传输协议
TCP 传输控制协议
IP 互联网协议地址
DNS 域名解析系统
CDN 内容分发网络
SSO 单点登陆
SSM Spring Springmvc mybatis
SSH spring struts2 hibernate 或者ssh协议

~~~

77、我们在哪些技术当中见过   #	$

~~~
# properties中注释 spel mybatis表示占位符#{}
$ jquery el表达式 mybatis表示字符串拼接
~~~



78、截至目前，我们用过哪些校验插件

~~~
validate JSR303 Hibernate Validator
~~~



79、spring当中的模块有哪些

~~~
1.      Spring AOP  面相切面编程

2.      Spring ORM  Hibernate|mybatis|JDO

3.      Spring Core  提供bean工厂 IOC

4.      Spring Dao  JDBC支持

5.      Spring Context  提供了关于UI支持,邮件支持等

6.      Spring Web 提供了web的一些工具类的支持

7.      Spring MVC  提供了web mvc , webviews , jsp ,pdf ,export
~~~



80、spring的优点是什么

~~~
IOC 控制反转 将对象创建和管理的权力交给spring完成 程序员只需要完成业务逻辑的编写即可
AOP 面向切面编程 将许多重复重要但又不属于业务逻辑的代码提取 通过动态代理来完成对方法的增强
~~~



## 8.3 课堂内容

### 8.3.1 mybatis

~~~xml
<!--mybatis-config配置文件-->
<?xml version="1.0" encoding="UTF-8" ?>
        <!DOCTYPE configuration
                PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 环境配置 -->
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC" />
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver" />
                <property name="url" value="jdbc:mysql://localhost:3306/test" />
                <property name="username" value="root" />
                <property name="password" value="zhangli" />
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <package name="net.wanho.mapper"></package>
        <mapper resource="net/wanho/mapper/UserMapper.xml"></mapper>
    </mappers>
</configuration>
~~~

~~~xml
<!--在UserMapper接口同一个包下创建UserMapper.xml 要求名字一样 否则需要在mybatis-config下的mapper中配置resource Mapper.xml中的空间名称和对应的接口全路径名一样  -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="net.wanho.mapper.UserMapper1">


	<parameterMap id="map" type="net.wanho.entity.User">
		<parameter property="id" resultMap="int"></parameter>
		<parameter property="name" resultMap="string"></parameter>
	</parameterMap>

	<resultMap id="resultMap" type="net.wanho.entity.User">
		<id property="id" column="id"></id>
		<result property="name" column="name"></result>
	</resultMap>

	<insert id="insertUser1" parameterMap="map">
		insert into t_user(id,name) values(#{id},#{name})
	</insert>

	<insert id="insertUser" parameterType="net.wanho.entity.User">
		insert into t_user(id,name) values(#{id},#{name})
	</insert>

	<insert id="insertUser3" parameterType="net.wanho.entity.User" useGeneratedKeys="true" keyProperty="id">
		insert into t_user(name) values(#{name})
	</insert>

	<insert id="insertUser4" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="AFTER" resultType="java.lang.Integer">
			select LAST_INSERT_ID()
		</selectKey>
		insert into t_user(name) values(#{name})
	</insert>

	<insert id="insertUser5" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="BEFORE" resultType="java.lang.Integer">
			select ifnull(max(id),0)+1 as id  from t_user1;
		</selectKey>
		insert into t_user1(id,name) values(#{id},#{name})
	</insert>

	<select id="queryUsers" resultMap="resultMap">
		select * from t_user
	</select>


	<select id="queryUsers1" resultMap="resultMap">
		select * from t_user
	</select>


	<delete id="deleteUser">
		delete from t_user where id= #{id}
	</delete>
	
	<update id="updateUser" parameterType="net.wanho.entity.User">
		update t_user set name=#{name} where id=${id}
	</update>
</mapper>
~~~

~~~java
 		String resource = "mybatis-config.xml";
        //获取文件的输入流
        Reader reader = Resources.getResourceAsReader(resource);
        //以文件为基础创建SqlSession的工厂类：SqlSessionFacotory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        //以工厂类为前提，创建sqlsession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //通过sqlsession获取接口
        UserMapper1 userMapper = sqlSession.getMapper(UserMapper1.class);

        User user = new User();
        user.setName("xiaolili");
        userMapper.insertUser5(user);
        sqlSession.commit();



//        Map<String, String> map = new HashMap();
//        map.put("id", "4");
//        map.put("name", "23erfg7ytfdx");
//        userMapper.insertUser1(map);
//        userMapper.updateUser(new User(133,"efg"));
//        sqlSession.commit();
//        userMapper.deleteUser(3);
//        sqlSession.commit();

//        userMapper.insertUser(new User());

        List<User> list = userMapper.queryUsers();
        System.out.println(list);
~~~



### 8.3.2 #{}和${}的区别

~~~
#{}相当于占位符 ${}相当于字符串拼接 会有sql注入问题

~~~



### 8.3.3 参数传递问题

~~~xml
<!--parameterType可以没有 只要#{}中的变量名和属性名相同即可-->
<update id="updateUser" parameterType="net.wanho.entity.User">
		update t_user set name=#{name} where id=${id}
</update>
~~~



### 8.3.4 mysql中主键自动增长返还

~~~xml
<!--第一种 主键自增是前提  直接在标签中配置useGeneratedKeys="true" keyProperty="id"之后就会将插入的id自动放进传递过来的User参数中-->
<insert id="insertUser3" parameterType="net.wanho.entity.User" useGeneratedKeys="true" keyProperty="id">
		insert into t_user(name) values(#{name})
</insert>
<!--第二种方法 在执行之后 order="after" 将selectKEY中获取的值放入传递过来的User参数的
	keyProperty="id"  id中
-->
<insert id="insertUser4" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="AFTER" resultType="java.lang.Integer">
			select LAST_INSERT_ID()
		</selectKey>
		insert into t_user(name) values(#{name})
	</insert>
<!--如果主键没有自动增长 先执行order="BEFORE" selectKey中的值 将结果放入传递过来的User参数的
	keyProperty="id"  id中 之后User就有id的值 那么下面的sql语句中就可以用该值-->
<insert id="insertUser5" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="BEFORE" resultType="java.lang.Integer">
			select ifnull(max(id),0)+1 as id  from t_user1;
		</selectKey>
		insert into t_user1(id,name) values(#{id},#{name})
	</insert>
~~~



### 8.3.5 ResultMap

~~~xml
<!--如果返还的的结果中 数据库的字段是name 但是接收的javabean中的字段是name1
	就可以用map来当作映射 将结果封装进User中
-->
<resultMap id="resultMap" type="net.wanho.entity.User">
		<id property="id" column="id"></id>
		<result property="name1" column="name"></result>
	</resultMap>
	
	<select id="queryUsers1" resultMap="resultMap">
		select * from t_user
	</select>
~~~

### 8.3.6 parameterType中普通参数

~~~
int _int integer java.lang.Integer
~~~



### 8.3.7 mybatis注解方式

~~~java
//@Results Result select insert update delete
public interface UserMapper {

    @Results({
            @Result(
                    property = "name",column = "name"
            ),
            @Result(
                    property = "id",column = "id"
            )}
    )
    @Select("select * from t_user")
    List<User> queryUsers();
  
    @Insert("insert into t_user(id,name) values(#{id},#{name})")
    void insertUser5(User user);
   
}
~~~

 

### 8.3.8  Hibernate 

具体看文档



### 8.3.9 docker 

具体看第三天的linux笔记



# day 09

## 9.1 简答题

81、ER图的作用、ORM技术有哪些

~~~
E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。

mybatis hibernate
~~~



82、举例说明数据库当中一对一、一对多、多对多

~~~
账号与用户表 一对一
用户和订单表 一对多
用户和商品表 多对多
~~~



83、我们学习过哪些以空间换时间或者以时间换空间的技术

~~~
单例模式中的饿汉模式 空间换时间
单例模式中的饱汉模式 时间换空间
~~~



84、主键自动增长怎么实现？插入数据库之后的主键返回来怎么实现？

~~~xml
mysql auto_increament
oracle sequence

<!--第一种 主键自增是前提  直接在标签中配置useGeneratedKeys="true" keyProperty="id"之后就会将插入的id自动放进传递过来的User参数中-->
<insert id="insertUser3" parameterType="net.wanho.entity.User" useGeneratedKeys="true" keyProperty="id">
		insert into t_user(name) values(#{name})
</insert>
<!--第二种方法 在执行之后 order="after" 将selectKEY中获取的值放入传递过来的User参数的
	keyProperty="id"  id中
-->
<insert id="insertUser4" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="AFTER" resultType="java.lang.Integer">
			select LAST_INSERT_ID()
		</selectKey>
		insert into t_user(name) values(#{name})
	</insert>
<!--如果主键没有自动增长 先执行order="BEFORE" selectKey中的值 将结果放入传递过来的User参数的
	keyProperty="id"  id中 之后User就有id的值 那么下面的sql语句中就可以用该值-->
<insert id="insertUser5" parameterType="net.wanho.entity.User">
		<selectKey  keyProperty="id" order="BEFORE" resultType="java.lang.Integer">
			select ifnull(max(id),0)+1 as id  from t_user1;
		</selectKey>
		insert into t_user1(id,name) values(#{id},#{name})
	</insert>
~~~



85、#与$的区别？sql注入是怎么回事

~~~
#表示占位符 $表示sql拼接
sql注入是当使用sql拼接时 在条件后面输入and where 1=1那么就会把所有的记录都能查出来 
~~~



86、在java当中如何调用存储过程、函数CallableStatement

~~~java
CallableStatement cstmt = con.prepareCall( "{call getTestData(?, ?)}"); 
cstmt.registerOutParameter(1, java.sql.Types.TINYINT); 
cstmt.registerOutParameter(2, java.sql.Types.DECIMAL, 3); 
cstmt.executeQuery(); 
byte x = cstmt.getByte(1); 
java.math.BigDecimal n = cstmt.getBigDecimal(2, 3); 
~~~



87、mybatis与hibernate的区别

~~~
（1）sql方面：mybaits通过mapper.xml维护映射结果，程序员手动编写sql相比hibernate自动生成hql（hibernate sql）更加灵活，sql调优更加容易（hibernate因为更好的封装性，开发效率提高的同时，sql语句调优要更费力，当然可以手动修改sql来优化，但是同时也会影响开发效率）；hibernate的hql数据库移植性更好，体现在强壮性。hibernate在级联删除的时候效率低；数据量大， 表多的时候，基于关系操作会变得复杂。

（2）缓存方面：mybatis和hibernate都可以使用第三方缓存，而hibernate相比maybatis有更好的二级缓存机制。
~~~



88、mysql与oracle在语法上的区别

~~~
mysql	int		limit	auto_increament
oracle	number	rownum	sequence
~~~



89、重写与重载的区别？变量、成员变量、局部变量、静态变量、实例变量、常量、属性的区别

~~~
重写是子类对父类方法的重写 重载是类中方法参数不同 调用不同的方法
1.成员变量：作用范围是整个类，相当于C语言中的全局变量，定义在方法体和语句块之外，一般定义在类的声明之下;成员变量包括：实例变量、类变量(又叫静态变量)和常量。

2.局部变量：作用范围在它定义的方法体或者语句块内部，出了这个范围就无效了。

3.实例变量：不用static修饰的成员变量，随对象的创建而创建，每个对象都有自己的独有的实例变量，属于对象私有;调用要实例化对象，用对象名.实例变量名才可以调用，如：Demo demo = new Demo(); int YouAge = demo.age;(当然，一般都会将成员变量设为private，通过属性方法调用)。

4.静态变量：用static修饰的成员变量，又叫类变量，一个类里只有一份，属于对象共有，调用是一般用类名.静态变量名就可以调用，或者用对象名.静态变量名也可以调用，调用的都是同一个变量，如:Demo.height。

5.类变量：和静态变量是同一个概念。

6.常量：用static final修饰的成员变量叫常量，在类中也是只有一份，同时不可以修改它的值。

7.字段：通常是在类中定义的成员变量，所以也和成员变量的概念差不多是一个意思。

8.属性：属性是只局限于类中方法的声明，不与其他的类成员相关。只与类中的get()/set()方法有关。

~~~



90、final, finally,finalize的区别；throw， throws的区别；continue/break/return的区别；void是不是一个类型？

~~~
1、final修饰符（关键字）。
被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将变量或方法声明为final，可以保证他们在使用的过程中不被修改。

2、finally是在异常处理时提供finally块来执行任何清除操作。
不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。

3、finalize是方法名。
java技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize方法以整理系统资源或者被执行其他清理工作。

throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。

break跳出循环 continue不执行当前循环下面的语句 开始下一次循环
return 方法结束 返回值

void表示无类型
~~~





## 9.3 课堂内容

### 9.3.1 mybatis 一级缓存

~~~
mybatis一级缓存是sqlSession级别的 在同一个sqlsession中 同义词查询只会执行一次sql语句
执行完第一次后会将对象放进一级缓存中 只要数据库没有变化 后面的同样查询就会去一级缓存中找
缓存都是为了加快查询速度，并且都是放在内存。缓存的数据来自于数据库。
凡是缓存都会涉及到两份数据，因此，必然产生数据不一致问题。
mybatis的缓存一致性解决就是：只要数据改变，一定清除缓存；下一次查，发现缓存中没有，就回到数据库中查询，然后放到缓存；下下依次查，就直接取缓存。一级缓存是sqlsession级别。

二级缓存是Mapper级别的 同一个Mapper 中相同的查询只会执行一次

~~~



### 9.3.2 mybatis 一对一

~~~xml
<!--查询返回值类型中有单个的成员变量 那么就是一对一 通过association来对应 property永远表示实体类中的成员变量名  association表示实体类中的user中的id变量名-->
<resultMap id="login" type="net.wanho.entity.Login">
		<id property="id" column="id"></id>
		<result property="username" column="username"></result>
		<result property="pwd" column="pwd"></result>
		<association property="user" javaType="net.wanho.entity.User">
			<id property="id" column="uid"></id>
		</association>
</resultMap>

<select id="selectuser" parameterType="int" resultType="net.wanho.entity.User">
		select * from t_user where id=#{uid}
</select>
~~~



### 9.3.3 懒加载

~~~xml
<!--在mybatis-config中配置 开启懒加载-->   
<settings>
        <setting name="lazyLoadingEnabled" value="true"/>
        <setting name="aggressiveLazyLoading" value="false"/>
    </settings>
~~~



~~~xml
	<!--map中的association中的user的赋值时通过select属性中的查询语句进行的 这个查询一句需要一个参数 使用 column当作参数传递过去-->
	<resultMap id="selectLogin" type="login">
		<id property="id" column="id"></id>
		<result property="username" column="username"></result>
		<result property="pwd" column="pwd"></result>
		<association property="user" select="selectuser" column="uid">
		</association>
	</resultMap>


	<!--这是单表的查询 使用懒加载 返回值是上面的map-->
	<select id="selectuser" parameterType="int" resultType="net.wanho.entity.User">
		select * from t_user where id=#{uid}
	</select>




	<!--另一个查询语句 用来查询实体类中的实体类 parameterType必须和accociation中的property类型一致-->
	<select id="queryLogin" parameterType="login" resultMap="selectLogin" >
		select * from t_login where username=#{username} and pwd=#{pwd}
	</select>
~~~



### 9.3.4 一对多

~~~xml
	<!--返还的map 由于class中有一个user的list 因此用collection user是通过另一个查询语句查询出来的
		selectUser来进行查询 selectUser需要查出对应这个班级的id  所以把这个班级的id传过去 user表中有个外		键是classid
-->
	<resultMap id="resultMap" type="net.wanho.entity.Clazz">
		<id property="id" column="id"></id>
		<result property="name" column="name"></result>
		<collection property="users" select="selectuser" column="id"></collection>
	</resultMap>
	
<!--主要的查询方法 需要一个resultMap 在上面-->
	<select id="queryClass" parameterType="_int" resultMap="resultMap">
		select * from t_class where id=#{id}
	</select>

	<select id="selectuser" resultType="net.wanho.entity.User">
		select * from t_user where classid=#{id}
	</select>
~~~



### 9.3.5 多对一

~~~xml
	<resultMap id="resultMap1" type="net.wanho.entity.User">
		<id property="id" column="id"></id>
		<result property="name" column="name"></result>
		<association property="clazz" select="selectclass" column="classid"></association>
	</resultMap>
	<!--主要的查询方法-->
	<select id="getUserById" resultMap="resultMap1">
		select * from t_user where id=#{id}
	</select>

	<select id="selectclass" resultMap="resultMap">
		select * from t_class where id=#{id}
	</select>
~~~



### 9.3.6 多对多

~~~xml
<!--多对多的情况有三张表 user course user_course 
	生成三个实体类 user和cource类里面没有褓韩别的实体类 而user_course包含别的实体类 分别有一个user  有一个course对象
-->
	<resultMap id="resultMap" type="net.wanho.entity.UserCourse">
		<id property="id" column="id"></id>
		<association property="user" select="selectuser" column="userid"></association>
		<association property="course" select="selectcourse" column="courceid"></association>
	</resultMap>
<!--主要的查询方法-->
	<select id="selectusercourses" resultMap="resultMap">
		select * from t_user_course
	</select>

	<select id="selectuser" resultType="net.wanho.entity.User">
		select * from t_user where id=#{id}
	</select>

	<select id="selectcourse" resultType="net.wanho.entity.Course">
		select * from t_course where id=#{id}
	</select>
~~~



~~~java
//中间表
public class UserCourse implements Serializable {
    private int id;
    private Course course;
    private User user;   
}

//user表 和中间表关系是 一对多 一个user对应多个course
public class User implements Serializable {
    private int id;
    private String name;
}

//course表 与中间表的关系是 一对多  一个course对应多个user
public class Course implements Serializable {
    private int id;
    private String name;
}
~~~



### 9.3.7 ssm环境搭建

1.pom文件jar包依赖 完成后启动tomcat插件 输入响应ip查看配置是否正确

~~~xml
<!--在properties中申明版本的信息，在dependencies当中引用这些版本信息。如此使用，一旦版本有所改变，则直接修改properties中的信息即可-->
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>4.12</junit.version>
        <spring.version>3.2.18.RELEASE</spring.version>
        <mybatis.version>3.2.8</mybatis.version>
        <mybatis.spring.version>1.2.2</mybatis.spring.version>
        <mybatis.pagehelper>5.1.2</mybatis.pagehelper>
        <mysql.version>5.1.32</mysql.version>
        <slf4j.version>1.6.4</slf4j.version>
        <jackson.version>2.4.2</jackson.version>
        <druid.version>1.0.9</druid.version>
        <jstl.version>1.2</jstl.version>
        <commons-fileupload.version>1.3.1</commons-fileupload.version>
    </properties>
    <dependencies>
        <!-- 单元测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- 日志处理 -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <!-- Mybatis -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>${mybatis.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>${mybatis.spring.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>${mybatis.pagehelper}</version>
        </dependency>
        <!-- MySql -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.version}</version>
        </dependency>
        <!-- 连接池 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>${druid.version}</version>
        </dependency>
        <!-- Spring -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jms</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context-support</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.47</version>
        </dependency>
        <!-- Jackson Json处理工具包 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>

        <dependency>
            <groupId>commons-fileupload</groupId>
            <artifactId>commons-fileupload</artifactId>
            <version>${commons-fileupload.version}</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>ssm_crud</finalName>
        <!--约束了src/main/java下面所有的xml都被打包到war包，特别用于确保mybatis中所有接口对应的xml打包到war包-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>

            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
            </resource>
        </resources>
        <!--配置tomcat插件，项目路径为/，端口为8088-->
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <configuration>
                    <path>/</path>
                    <port>8088</port>
                </configuration>
            </plugin>
        </plugins>
    </build>
~~~

~~~xml
<!--如果spring版本为4.2.x jackson版本需要2.7-->
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <junit.version>4.12</junit.version>
    <spring.version>4.3.18.RELEASE</spring.version>
    <mybatis.version>3.2.8</mybatis.version>
    <mybatis.spring.version>1.2.2</mybatis.spring.version>
    <mybatis.pagehelper>5.1.2</mybatis.pagehelper>
    <mysql.version>5.1.32</mysql.version>
    <slf4j.version>1.6.4</slf4j.version>
    <jackson.version>2.7.3</jackson.version>
    <druid.version>1.0.9</druid.version>
    <jstl.version>1.2</jstl.version>
    <commons-fileupload.version>1.3.1</commons-fileupload.version>
  </properties>
  <dependencies>
    <!-- 单元测试 -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>${junit.version}</version>
      <scope>test</scope>
    </dependency>
    <!-- 日志处理 -->
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>${slf4j.version}</version>
    </dependency>
    <!-- Mybatis -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>${mybatis.version}</version>
    </dependency>
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>${mybatis.spring.version}</version>
    </dependency>
    <dependency>
      <groupId>com.github.pagehelper</groupId>
      <artifactId>pagehelper</artifactId>
      <version>${mybatis.pagehelper}</version>
    </dependency>
    <!-- MySql -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>${mysql.version}</version>
    </dependency>
    <!-- 连接池 -->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>${druid.version}</version>
    </dependency>
    <!-- Spring -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-beans</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aspects</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jms</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context-support</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>fastjson</artifactId>
      <version>1.2.47</version>
    </dependency>
    <!-- Jackson Json处理工具包 -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>${jackson.version}</version>
    </dependency>

    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>${commons-fileupload.version}</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>
  </dependencies>

  <build>
    <finalName>ssm_crud</finalName>
    <!--约束了src/main/java下面所有的xml都被打包到war包，特别用于确保mybatis中所有接口对应的xml打包到war包-->
    <resources>
      <resource>
        <directory>src/main/java</directory>
        <includes>
          <include>**/*.xml</include>
        </includes>
      </resource>

      <resource>
        <directory>src/main/resources</directory>
        <includes>
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
      </resource>
    </resources>
    <!--配置tomcat插件，项目路径为/，端口为8088-->
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <configuration>
          <path>/</path>
          <port>8088</port>
        </configuration>
      </plugin>
    </plugins>
  </build>
~~~



2.创建controller service mapper entity层  在创建springmvc.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--扫描controller层-->
    <context:component-scan base-package="net.wanho.controller"></context:component-scan>
    <!--以标签的方式创建处理器映射器以及处理器适配器-->
    <mvc:annotation-driven></mvc:annotation-driven>
</beans>

~~~

3创建applicationContext-service.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <!--扫描controller层-->
    <context:component-scan base-package="net.wanho.service"></context:component-scan>
</beans>

~~~

4.创建一个file 名叫Mybatis-config.xml

~~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
        </plugin>
    </plugins>
</configuration>
~~~~

5.创建applicationContext-dao.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置数据库连接池，使用的是druid-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/ssm"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123"></property>
    </bean>

    <!--配置SqlSession的工厂-->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="configLocation"  value="classpath:Mybatis-config.xml"/>
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--配置数据库操作的接口以及xml所在package-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="net.wanho.mapper"></property>
    </bean>
</beans>
~~~

6.创建applicationContext-trans.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!--设置事务管理器，引用的是applicationContext-dao.xml中配置的datasource-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--配置事务通知，引用上面设置的事务管理器
        add、delete、update开头的方法需要事务
        其他方法都是只读的
    -->
    <tx:advice id="advice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="add*" propagation="REQUIRED"/>
            <tx:method name="update*" propagation="REQUIRED"/>
            <tx:method name="delete*" propagation="REQUIRED"/>
            <tx:method name="*" read-only="true"/>
        </tx:attributes>
    </tx:advice>

    <!--定义连接点，advisor定义了通知在连接点上执行即织入-->
    <aop:config>
        <aop:pointcut id="pointcut" expression="execution(* net.wanho.service.*.*(..))"></aop:pointcut>
        <aop:advisor advice-ref="advice" pointcut-ref="pointcut"></aop:advisor>
    </aop:config>
</beans>
~~~

7.在web.xml中配置 父容器 子容器

~~~xml
  <!--该节点定义了spring父容器所要读取的文件，applicationContext-*.xml表明所有以"applicationContext-"都会被加载-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext-*.xml</param-value>
  </context-param>
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <!--init-param节点定义了spring子容器所要读取的文件，load-on-startup保证了系统启动之时就会加载该servlet-->
  <servlet>
    <servlet-name>mvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <!--url-pattern节点的"/"取值，保证了所有的url都会被拦截-->
  <servlet-mapping>
    <servlet-name>mvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
~~~

8.xxxMapper.xml

~~~xml
<mapper namespace="net.wanho.mapper.StudentMapper">
    <!--id的值与接口中方法名同名，parameterType即方法的参数类型，
        useGeneratedKeys即使用自增主键，keyProperty定义了主键-->
    <insert id="add" parameterType="net.wanho.entity.Student" useGeneratedKeys="true" keyProperty="id">
        insert into t_student(name) values(#{name})
    </insert>

    <select id="get" parameterType="int" resultType="net.wanho.entity.Student">
        select * from t_student where id=#{id}
    </select>
</mapper>
~~~

9.serviceImpl中得到mapper接口的实现类 直接用注入即可 因为applicaitonContext-dao中进行了扫描

~~~java
@Service
public class StudentServiceImpl implements StudentServiceI {

    //注入StudentMapper
    @Resource
    private StudentMapper studentMapper;

    public void addStudent(Student student) throws Exception {
        studentMapper.add(student);
    }

    public Student getStudent(int id) {
        return studentMapper.get(id);
    }
}
~~~

10.controller中注入service

~~~java
@Controller
public class StudentController {

    @Resource
    private StudentServiceI studentService;

    @RequestMapping(value="/student/add/{name}",method = RequestMethod.GET)
    @ResponseBody
    public JSONObject addStudent(Student student)
    {
        JSONObject ret = new JSONObject();
        try {
            studentService.addStudent(student);
            ret.put("status",200);
            ret.put("msg","add success:"+student.getId());
        }
        catch(Exception e)
        {
            ret.put("status",100);
            ret.put("msg","add error");
            e.printStackTrace();
        }
        return ret;
    }

    @RequestMapping(value = "/student/get/{id}",method = RequestMethod.GET)
    @ResponseBody
    public JSONObject getStudent(Student student){
        JSONObject ret = new JSONObject();
        try {
            student = studentService.getStudent(student.getId());
            ret.put("status",200);
            ret.put("msg",student);
        } catch (Exception e) {
            ret.put("status",100);
            ret.put("msg","add error");
            e.printStackTrace();
        }
        return ret;
    }
}
~~~



# day10

## 10.1 简答题

91.解释mybatis的延迟加载？延迟加载技术在哪里遇到过

~~~
mybatis延迟加载是当一个类中包含另一个类 即一对一或者多对一的关系时 只查询外面的那个类里的数据 当需要用到里面类的东西时 再通过sql语句进行查询封装

servlet创建时 用到了才会创建

~~~

92.解释mybatis的一二级缓存。如何实现

~~~
一级缓存是sqlSession级别的
二级缓存是Mapper级别的
二级缓存需要用到ehcache 再导入ehcache的xml文件 并且再mapper中使用
~~~

93.mybatis当中的collection，association分别是干啥的

~~~
collection是一对多
association是一对一或多对一
~~~

94.解释ER,ORM,MVC,AOP,IOC,DI,OOP,O2O,PPP

~~~
ER:实体对象关系模型
ORM:对象关系映射
MVC:模型(model)－视图(view)－控制器(controller)的缩写
AOP:面向切面编程
IOC:控制反转
DI:依赖注入
OOP：面向对象编程
o2o：Online To Offline（在线离线/线上到线下）
PPP：面向领域编程
~~~

95.putty、xshell、crt、filezilla、postman、netbeans是干什么的

~~~
putty、xshell、crt:可以通过ssh/telnet或者其他协议来远程连接终端
filezilla：通过ftp协议传输文件
postman：可以测试接口 压力测试
netbeans：一个IDE
~~~



96、解释被代理类、代理类、切面、连接点、切入点、织入、通知

~~~
被代理类：需要被增强的类

代理类:被代理类增强后生成的类

切面： 
定义：切面是通知和切点的集合，通知和切点共同定义了切面的全部功能——它是什么，在何时何处完成其功能。

连接点： 
定义：连接点是一个应用执行过程中能够插入一个切面的点。

通知： 
定义：切面也需要完成工作。在 AOP 术语中，切面的工作被称为通知。

织入： 
织入是将切面应用到目标对象来创建的代理对象过程。

切点： 
定义：如果通知定义了“什么”和“何时”。那么切点就定义了“何处”。切点会匹配通知所要织入的一个或者多个连接点。
~~~



97、jdk动态代理与cglib动态代理的区别

~~~
jdk动态代理是通过接口实现的 InvocationHandler
cglib是通过继承实现的	MethodInterceptor
~~~

98、tx：annotation-driven、mvc：annotation-driven、aop:autoproxy、aop：config、context:componentsan、tx:advice的作用

~~~
tx：annotation-driven：注解事务
mvc：annotation-driven：处理器适配器 处理器映射器
aop:autoproxy 注解aop
aop：config 配置aop或者事务
context:componentsan spring或springmvc包扫描
tx:advice： 注解事务配置具体方法和传播特性
~~~



99、与$相关的技术有哪些

~~~
el jquery spring配置文件应用外部properties
~~~



100.项目具体流程有哪些

~~~
项目流程：立项、可行性分析、需求分析评审、概要设计、详细设计、编码/单元测试、模块测试、集成测试、系统测试、验收测试、部署、运维     下一个周期/迭代
~~~





## 10.3 课堂内容

### 10.3.1 pageHelper分页

~~~xml
//需要先设置PageHelper.startPage(pageNum,pageSize); 
通知hibernate延迟查询 不然就是假分页 查询全部
<!--需要在mybatis-config.xml中配置拦截器-->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
        </plugin>
    </plugins>
</configuration>


~~~

~~~java
			PageHelper.startPage(pageNum,pageSize);
           	 List<Student> students = studentService.queryStudents();
           	 PageInfo<Student> pageInfo = new PageInfo<Student>(students);
           	 ret.put("status",200);
           	 ret.put("data",pageInfo);
~~~



### 10.3.2 二级缓存

```xml
<!--在pom.xml中要带入一下jar包要导一个包：-->
<dependency>
      <groupId>org.mybatis.caches</groupId>
      <artifactId>mybatis-ehcache</artifactId>
      <version>1.0.3</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.25</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.25</version>
    </dependency>
<!--二级缓存：在mybatis-config中开启二级缓存-->
 <setting name="cacheEnabled" value="true"></setting>
<!--二级缓存：在userMapper.xml中配好这些-->
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>

<!--一级缓存是sqlsession级别，二级缓存是mapper级别的，命中的概念：先去缓存中查第一次肯定差不多，之后查几次最多只可能无线接近于1，不会等于到1。-->

```

### 10.3.3 pageHelper分页组件的使用

```xml
<!--在mybatis-config.xml中进行如下配置：-->
<plugins>
        <!-- com.github.pagehelper为PageHelper类所在包名 -->
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
        </plugin>
 </plugins>
<!--在pom.xml中导入如下jar包：-->
    <dependency>
      <groupId>com.github.pagehelper</groupId>
      <artifactId>pagehelper</artifactId>
      <version>5.1.4</version>
    </dependency>
<!--如下为测试：-->
UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);
        PageHelper.startPage(2,4);<!--（这个要放在最前面，不然查询的时候不知道当前页和pageSize）-->
        List<UserCourse> list =  userMapper1.selectusercourses();
        PageInfo<UserCourse> pageInfo = new PageInfo(list);<!--（创建pageInfo对象将list传进去即可）-->
```

### 10.3.4 sql片段_include_if完整的sql查询

```xml
include代码实现：
<sql id="coursecls">
		id,name from
</sql><!--通过这边自己定义的列名，传到下面的sql语句中-->
<select id="selectcourse2" resultType="net.wanho.entity.Course">
		select <include refid="coursecls"></include> t_course where 1=1
    <!--这边where后边不能直接加上and，所以添加了1 = 1 这个条件-->
		<if test="name!=null">
			and name=#{name}
		</if>
</select>
```

### 10.3.5 sql片段_choose_when

```xml
<!--具体代码如下，还是要依赖与自定义的列名：include-->
<sql id="coursecls">
		id,name from
</sql>
<select id="selectcourse3" resultType="net.wanho.entity.Course">
		select <include refid="coursecls"></include> t_user where 1=1
		<choose>
			<when test="name!=null">
				and name=#{name}
			</when>
			<otherwise>
				and name is null
			</otherwise>
		</choose>
	</select>
```

### 10.3.6 sql片段_where_foreach









# day11

## 11.3 课堂内容

### 11.3.1 springboot中使用jsp

~~~
使用jsp需要一个依赖jar包 在pom中配置
tomcat-embed-jasper
否则会下载

在main下创建一个目录 webapp
选择file》》project Structure》》Modules》》下面的加号 然后选择webapp的目录 》》apply》》ok
~~~

~~~
要使用maven的install需要跳过test单元测试 在pom下配置跳过单元测试
springboot达成的jar包
~~~

### 11.3.2 springboot打成jar包

不会将webapp下的页面打包进去 所以需要在pom.xml中配置 但是用springboot插件启动不会有这种情况

~~~xml
		<resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/**</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/webapp</directory>
            </resource>
        </resources>
~~~



### 11.3.3 页面资源位置

~~~java
所有的jsp页面需要新建一个webapp 如上所述
所有的静态资源（html/js/css/图片/字体）放在resource的static下

如在@Configuration的配置类下面加了@EnableWebMvc 那么springmvc就像之前ssm框架一样会把静态资源也当作controller请求去处理器映射器中查找
这种情况需要在@Configuration配置类中配置
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
//        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
    }
    

不加@EnableWebMvc static下的静态资源都可以访问
~~~

### 11.3.4 @Configuration中的配置

~~~java
@Configuration
public class MyConfiguration extends WebMvcConfigurerAdapter {

	//视图解析器
    @Bean
    public ViewResolver getViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/view/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
    //配置欢迎页
    public void addViewControllers(ViewControllerRegistry registry) {

        registry.addViewController("/").setViewName("forward:/login.jsp");

        registry.setOrder(Ordered.HIGHEST_PRECEDENCE);

        super.addViewControllers(registry);
    }

	
	//配置过滤器
    @Bean
    public FilterRegistrationBean testFilterRegistration() {
        FilterRegistrationBean registration = new FilterRegistrationBean(new LoginFilter());
        registration.addUrlPatterns("/*"); //
        registration.addInitParameter("charset", "UTF-8"); //
        registration.setName("EncodingFilter");
        return registration;
    }

	//和下面配合使用 访问静态资源
  /*  　　此时会注册一个默认的Handler：DefaultServletHttpRequestHandler，这个Handler也是用来处理静态文件的，它会尝试映射/*。当DispatcherServelt映射/时（/ 和/* 是有区别的），并且没有找到合适的Handler来处理请求时，就会交给DefaultServletHttpRequestHandler 来处理。注意：这里的静态资源是放置在web根目录下，而非WEB-INF 下。 
　　可能这里的描述有点不好懂（我自己也这么觉得），所以简单举个例子，例如：在webroot目录下有一个图片：1.png 我们知道Servelt规范中web根目录（webroot）下的文件可以直接访问的，但是由于DispatcherServlet配置了映射路径是：/ ，它几乎把所有的请求都拦截了，从而导致1.png 访问不到，这时注册一个DefaultServletHttpRequestHandler 就可以解决这个问题。其实可以理解为DispatcherServlet破坏了Servlet的一个特性（根目录下的文件可以直接访问）*/
    public void configureDefaultServletHandling(
            DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    //配置资源映射 相当于springmvc配置文件中的resources 用来将静态文件路径匹配
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
    }
}
~~~



### 11.3.5  配置Spring bean

~~~java
public class MyConfiguration extends WebMvcConfigurerAdapter {


    @Bean
    public ViewResolver getViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/view/");
        resolver.setSuffix(".jsp");
        return resolver;
	}
~~~



### 11.3.6 入口文件的配置application.properties

~~~java
server.port=8666  //端口
spring.datasource.driver-class-name=com.mysql.jdbc.Driver   //jdbc
spring.datasource.url=jdbc:mysql://localhost:3306/project4		
spring.datasource.username=root
spring.datasource.password=123
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource		//连接池
mybatis.mapper-locations=classpath:mapper/*.xml					//mybatis配置文件扫描
mybatis.type-aliases-package=net.wanho.dto				//mybatis别名

#日志
logging.config=classpath:config/logback-spring.xml			配置日志文件
~~~



### 11.3.7 日志文件

~~~
在上面的文件中配置中配置
#日志
logging.config=classpath:config/logback-spring.xml			配置日志文件


之后在resouces目录下创建一个config congfig下创建logback-spring.xml 里面配置信息如下
~~~

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 此xml在spring-boot-1.5.3.RELEASE.jar里 -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml" />
    <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
    <!-- 开启后可以通过jmx动态控制日志级别(springboot Admin的功能) -->
    <!--<jmxConfigurator/>-->

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--<File>/home/hfw-client/hfw_log/stdout.log</File>-->
        <File>D:/log/hfw-client/hfw_log/stdout.log</File>
        <encoder>
            <pattern>%date [%level] [%thread] %logger{60} [%file : %line] %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 -->
            <!--<fileNamePattern>/home/hfw-client/hfw_log/stdout.log.%d{yyyy-MM-dd}.log</fileNamePattern>-->
            <fileNamePattern>D:/log/hfw-client/hfw_log/stdout.log.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory><!--  保留30天日志 -->
        </rollingPolicy>
    </appender>

    <logger name="com.moerlong.hfw.dao" level="DEBUG" />

    <root level="DEBUG">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
~~~



### 11.3.8 swagger 配置

新建一个类 这里面需要设置controller的路径

~~~java
package net.wanho.class124.springbootdemo.system;

//swagger2的配置文件，在项目的启动类的同级文件建立

        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        import springfox.documentation.builders.ApiInfoBuilder;
        import springfox.documentation.builders.PathSelectors;
        import springfox.documentation.builders.RequestHandlerSelectors;
        import springfox.documentation.service.ApiInfo;
        import springfox.documentation.service.Contact;
        import springfox.documentation.spi.DocumentationType;
        import springfox.documentation.spring.web.plugins.Docket;
        import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class Swagger2 {
    //swagger2的配置文件，这里可以配置swagger2的一些基本的内容，比如扫描的包等等
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                //为当前包路径
               .apis(RequestHandlerSelectors.basePackage("net.wanho.class124.springbootdemo.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    //构建 api文档的详细信息函数,注意这里的注解引用的是哪个
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title("Spring Boot 测试使用 Swagger2 构建RESTful API")
                //创建人
                .contact(new Contact("zhangli", "wh1993.net", "langli2049@163.com"))
                //版本号
                .version("1.0")
                //描述
                .description("API 描述")
                .build();
    }


}
~~~

~~~xml
	<!--导入jar包依赖-->      
		<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.4.0</version>
        </dependency>

        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.4.0</version>
        </dependency>
~~~

~~~java
//自定义配置文件的配置 由于springmvc拦截所有的静态文件 因此swagger的页面也会被拦截 需要放开该页面的访问
 //访问页面时swagger-ui.html
@Configuration
@EnableWebMvc
public class MyConfiguration extends WebMvcConfigurerAdapter {

    @Bean
    public User getUser() {
        return new User("ali");
    }

    @Bean
    public ViewResolver getViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/view/");
        resolver.setSuffix(".jsp");
        return resolver;
    }


    public void configureDefaultServletHandling(
            DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        registry.addResourceHandler("/js/**").addResourceLocations("classpath:/js/");
        registry.addResourceHandler("swagger-ui.html")
                .addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("classpath:/META-INF/resources/webjars/");
    }

}
~~~





# day12

## 12.1 简答题

101. 事物的隔离级别是什么，mysql oracle默认是哪个

     ~~~
     读未提交 读已提交 可重复度 串行化
     mysql 可重复度
     oracle 读已提交
     ~~~

     

102. 什么时脏读 幻读 不可重复度

     ~~~
     脏读(Dirty read)：在一个事务中读取到另一个事务已经修改但没有提交的数据。例如，事务A对数据进行了修改，但是还没有提交，这时事务B读取这个数据，然后事务A回滚，那么事务B取的数据无效。不符合一致性。
     
       不可重复读(NonRepeatable Read)：既不能读到相同的数据内容，事务A读取到了事务B已经提交的修改数据（一个事务范围内两个相同的查询却返回了不同数据）。例如事务A先读取数据，然后事务B对该同一数据修改并提交，那么事务A再次读取该数据时，由于事务B对该数据的修改，事务A两次读到的的数据可能是不一样的。不符合隔离性。
     
       幻读(Phantom Read)：事务A读取到了事务B已经提交的新增数据。在一个事务中，两次查询的结果不一致(针对的insert操作) 。例如事务A对一个表中的数据进行了修改，同时，事务B也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，事务A的用户后面的操作发现表中还有没有修改的数据行，就好象发生了幻觉一样。不符合隔离性。
     ~~~

     

103. 事物的传播特性有哪些

     ~~~
     propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
     propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。
     propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。
     propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。
     propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
     propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。
     propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作
     ~~~

     104、bean标签中的id、class、init-method、destory-method、factory-method、depends-on、scope、autowired分别是干什么的

     ~~~
     id 可以被别的bean中的ref引用
     class 改类的全路径
     init-method 初始化方法
     destory-method 销毁时执行的方法
     factory-method 工厂类执行的额方法
     depends-on 创建之前要依赖哪个类
     scope 生命周期
     autowird 自动装配
     ~~~

     

     105、后置处理器是什么

     ~~~
     在spring创建类之前或之后可以执行方法
     实现BeanPostProcessor接口 两个方法分别是在spring创建对象后 调用玩init-method方法前后执行 Object o 就是spring当前正在创建的类
     ~~~

     

     106、异常的体系

~~~
throwable 
 Exeption
  runtimeException
  非RuntimeException
 error
~~~

107、集合的体系结构

~~~
Collection
	List
		linkedList
		arraylist
	set
		Hashset
		treeset
Map
	hashmap
~~~



108、mybatis与hibernate的区别

~~~
mybatis 轻量级  通过sql语句进行数据库交互
hibernate 重量级 可以通过HQL语句
~~~



109、jdbc连接数据库的代码

~~~java
Class.forname(driver)
Connection con = DriverManager.getConnection(url,username,password)	
Preparement ps = con.preparedStatement(sql);
ps.execute();
~~~



110、什么是高内聚低耦合

~~~
耦合性称为：块间联系

指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。

内聚性称为：块内联系

指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。

~~~

111、springboot出现的意义是什么

~~~
减少了繁琐的配置 程序员只需要管业务逻辑的编写
~~~

112、springboot常用注解有哪些

~~~
@Configration
@MapperScan
@EnableMvc
@EnableTransactionManagement
~~~



113、springboot的主启动类的位置有什么意义

~~~
默认扫描它所在的包下 以及下面包下的所有类
~~~



114、springboot整合mybatis步骤有哪些

~~~
导入jar包
在application.yml中配置datasource和xml扫描
在主启动类配置接口扫描
~~~



115、springboot中jsp如何支持、视图解析器有哪两种配置方式

~~~
导入以来的jar包
创建webapp目录 
配置webapp目录加入到web中
~~~



116、什么是restful

~~~
一种编码规范
返回json格式 参数在路径中传递
根据增删改查 请求的method分别为 post delete put get
~~~



117、swagger是干什么的

~~~
用来对restful的api进行测试
~~~



118、shrio的六大功能、三大组件是什么

~~~
认证、授权、session管理、加密、记住我、web支持
subject 
securitymanager
realm
~~~



119、AuthrizingRealm的作用是什么

~~~
通过继承该类实现自定义的认证和授权
~~~



120、shiro中常用的类有哪些

~~~
SecurityManager IniSecurityManagerFactory UsernamePasswordToken SecurityUtils
~~~

## 12.3 课堂内容

### 12.3.1 热部署

~~~
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
  <optional>true</optional>
</dependency>
#热部署生效
spring.devtools.restart.enabled: true
#设置重启的目录
#spring.devtools.restart.additional-paths: src/main/java
#classpath目录下的WEB-INF文件夹内容修改不重启
spring.devtools.restart.exclude: WEB-INF/**
File-Settings-Compiler-Build Project automatically
ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running
~~~



### 12.3.2 shiro整合ssm

~~~xml
<!--添加依赖-->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-ehcache</artifactId>
            <version>1.2.2</version>
        </dependency>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-web</artifactId>
            <version>1.3.2</version>
        </dependency>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-spring</artifactId>
            <version>1.3.2</version>
        </dependency>

        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-quartz</artifactId>
            <version>1.2.2</version>
        </dependency>
~~~

~~~xml
<!--添加applicationContext-shiro.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


<!--凭证管理器-->
    <bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <!--加密方式-->
        <property name="hashAlgorithmName" value="md5"/>
        <!--加密次数-->
        <property name="hashIterations" value="2"/>
    </bean>

    <!--自定义realm-->
    <bean id="userRealm" class="net.wanho.security.MyRealm">
        <!--凭证管理器-->
        <property name="cachingEnabled" value="false"/>
    </bean>

    <!--缓存管理-->
    <bean id="cacheManager" class="org.apache.shiro.cache.MemoryConstrainedCacheManager"/>

    <!--记住我cookie-->
    <bean id="rememberMeCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <constructor-arg value="rememberMe"/>
        <!--记住我的cookie的有效期,默认单位是秒 7*24*60*60-->
        <property name="maxAge" value="604800"/>
    </bean>
    <!--rememberMeManager管理器-->
    <bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
        <property name="cookie" ref="rememberMeCookie"/>
    </bean>

    <!--安全管理器-->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="userRealm"/>
        <property name="cacheManager" ref="cacheManager"/>
        <property name="rememberMeManager" ref="rememberMeManager"/>
    </bean>



    <!--shiro的上下文（securityUtils.setSecurityManager）-->
    <bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
        <property name="staticMethod" value="org.apache.shiro.SecurityUtils.setSecurityManager"/>
        <property name="arguments" ref="securityManager"/>
    </bean>



    <!--shiro的web过滤器-->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证-->
        <property name="loginUrl" value="/login1.jsp"/>
        <!-- 通过unauthorizedUrl指定没有权限操作时跳转页面-->
         <property name="unauthorizedUrl" value="/nopermission.jsp" />
        <property name="filterChainDefinitions">
            <value>
                <!--
                anon  没有参数，匿名可用（不登录就能用的接口）
                authc 登录后才能使用，没有参数
                roles roles[admin,student] 表示登录后角色，至少有一个参数，多个参数中间用逗号隔开
                perms perms[admin:add,admin:update] 表示登录后拥有的权限，至少有一个参数，多个参数中间用逗号隔开
                rest [admin:post/get/delete]
                port port[8080]
                authcBasic http验证
                ssl https验证
                user 必须存在用户，必须登录
                -->
                /login = anon
                /** = user

            </value>
        </property>
    </bean>

    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <prop key="org.apache.shiro.authc.UnknownAccountException">/unknownaccount</prop>
                <prop key="org.apache.shiro.authc.IncorrectCredentialsException">/incorrectpwd</prop>
                <prop key="org.apache.shiro.authz.UnauthorizedException">/unknownaccount</prop>
            </props>
        </property>
    </bean>


    <!--spring对shiro的支持-->
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"/>
    </bean>

    <!--shiro生命周期-->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

    <!--会话的ID生成器-->
    <bean id="sessionIdGenerator" class="org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"/>

    <!--会话DAO-->
    <bean id="sessionDAO" class="org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO">
        <property name="activeSessionsCacheName" value="shiro-activeSessionCache"/>
        <property name="sessionIdGenerator" ref="sessionIdGenerator"/>
    </bean>

    <!--会话管理器-->
    <bean id="sessionManager" class="org.apache.shiro.session.mgt.DefaultSessionManager">
        <property name="globalSessionTimeout" value="1800000"/>
        <property name="deleteInvalidSessions" value="true"/>
        <property name="sessionValidationSchedulerEnabled" value="true"/>
        <property name="sessionValidationScheduler" ref="sessionValidationScheduler"/>
        <property name="sessionDAO" ref="sessionDAO"/>
    </bean>
    <!--调度器-->
    <bean id="sessionValidationScheduler" class="org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler">
        <property name="sessionValidationInterval" value="1800000"/>
        <property name="sessionManager" ref="sessionManager"/>
    </bean>
</beans>
~~~

~~~java
//里面有个自定义的realm 需要继承AuthorizingRealm
public class MyRealm extends AuthorizingRealm {

    //授权
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {


        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        //仅仅是暂时为了代替数据库查询而存在，实际使用中，肯定要去数据库查出来，是什么赋值什么
        info.addRole("admin1");
        info.addStringPermission("user:add");

        return info;
    }

    //认证
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;

        String pwd = new String((char[]) token.getCredentials());
        String username = (String) token.getPrincipal();


        if (!"zhangli".equals(username)) {
            throw new UnknownAccountException();
        }

        if (!"123456".equals(pwd)) {
            throw new IncorrectCredentialsException();
        }
        return new SimpleAuthenticationInfo(username, pwd, getName());


        //访问数据库，进行密码的匹配
    }
}
~~~

~~~java
//在需要授权才能访问的页面上加上注解
@Service
public class ShiroService {

	@RequiresRoles("admin")
    @RequiresPermissions("user:insert")
    public void check() {
        System.out.println(11234);
    }
}
~~~

~~~jsp
<!--在需要某些权限才能访问的jsp-->
    <shiro:hasPermission name="user:insert">
        <button>新增</button>
    </shiro:hasPermission>
    <shiro:hasRole name="admin">
        <button >删除</button>
    </shiro:hasRole>
~~~

### 12.3.3 springboot 整合hibernate

~~~java
//创建springboot项目时选择jpa 之后再application.yml中配置
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cms
    username: root
    password: zhangli
  jpa:
    database : mysql
    show-sql : true
    hibernate.ddl-auto : create
    hibernate.dialect : org.hibernate.dialect.MySQL5Dialect
~~~

~~~java
//dao层写一个接口 继承这个即可 之后不需要实现 直接配置entity
@Repository
public interface UserDao extends JpaRepository<User, Integer> {

}

~~~

~~~java
//entity的配置
@Entity
@Table(name = "t_user")
public class User implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Column(name = "name")
    private String name;

    public User(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
~~~

~~~java
//service层直接注入dao层即可
@Service
public class UserService {

    @Resource
    private UserDao userdao;

    public String insert(User user)
    {
        userdao.save(user);
        return "ok";
    }

}

~~~



# day13

## 13.1 themeleaf整合springboot

~~~xml
<!--引入依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
~~~

~~~xml
<!--themeleaf默认的模板映射路径是：src/main/resources/templates
即返回视图modelAndView或者String之后都会到这个路径下寻找html文件
相当于在springmvc中配置了视图解析器-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/templates"></property>
        <property name="suffix" value=".html"></property>
    </bean>
~~~



~~~xml
<!--配置thymeleaf视图解析器
　　　　这点与springMVC是相类似
　　　　配置在springboot的配置文件application.properties中-->
　　　
#thymeleaf start
spring.thymeleaf.mode=HTML5
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.content-type=text/html
#开发时关闭缓存,不然没法看到实时页面
spring.thymeleaf.cache=false
#thymeleaf end



<!--你可能会发现在默认配置下，thymeleaf对.html的内容要求很严格，比如<meta charset="UTF-8" />，
如果少最后的标签封闭符号/，就会报错而转到错误页。也比如你在使用Vue.js这样的库，然后有<div v-cloak></div>这样的html代码，
也会被thymeleaf认为不符合要求而抛出错误。

因此，建议增加下面这段：

spring.thymeleaf.mode = LEGACYHTML5
spring.thymeleaf.mode的默认值是HTML5，其实是一个很严格的检查，改为LEGACYHTML5可以得到一个可能更友好亲切的格式要求。

需要注意的是，LEGACYHTML5需要搭配一个额外的库NekoHTML才可用。-->
<dependency>  
       <groupId>net.sourceforge.nekohtml</groupId>  
       <artifactId>nekohtml</artifactId>  
       <version>1.9.22</version>  
</dependency>  

最后重启项目就可以感受到不那么严格的thymeleaf了。
~~~

~~~java
//controller层编写
@Controller
public class HelloController {
    private static final Logger log = LoggerFactory.getLogger(HelloController.class);

    @GetMapping(value = "/hello")
    public String hello(Model model) {
        String name = "jiangbei";
        model.addAttribute("name", name);
        return "hello";
    }
}
~~~

~~~html
<!--编写html摸板 放到resources/templates/下-->
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>hello</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>
    <!--/*@thymesVar id="name" type="java.lang.String"*/-->
    <p th:text="'Hello！, ' + ${name} + '!'">3333</p>
</body>
</html>q
~~~

简答题

201、画一下我们商城项目的拓扑图

202、tomcat当中的session共享与redis下的单点登录有什么不同

~~~
tomcat的session共享是将用户信息存储在session中，通过配置tomcat来实现分布式的session
redis单点登陆是将用户信息存储在redis中，将redis的key值返回给用户的浏览器，每次访问时都带着session
~~~



203、springboot当中主要注解有哪些

~~~
@bean @springbootAppliction @Configuration
~~~



204、application.yml与application.properties有什么不同

~~~
配置的格式不同 官方推荐使用yml
~~~



205、我们常见的模板技术有哪些

~~~
freemaker  themeleaf jquery.template
~~~



206、项目流程包括哪些

~~~
项目流程：立项、可行性分析、需求分析评审、概要设计、详细设计、编码/单元测试、模块测试、集成测试、系统测试、验收测试、部署、运维     下一个周期/迭代
~~~



207、常见的linux操作系统有哪些

~~~
centos redhat unix 
~~~



208、常见的数据库技术有哪些

~~~
mysql oracle DB2
~~~



209、redis当中的数据类型有哪些

~~~
string list hash set zset
~~~



210、为什么要引入activemq

~~~
主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。
~~~

211、java当中的基本类型有哪些，各占几个字节

~~~
byte short int long double float char boolean 
1	2		4	8	8	8		1	1
~~~



212、装箱拆箱是什么

~~~
装箱拆箱是java将基本类型和包装类型进行转化
~~~



213、jdk8的新特性有哪些

~~~
lambda表达式
~~~



214、泛型有什么意义

~~~
将运行时的异常提前到编译时
~~~

215、反射是干什么的

~~~
反射可以根据提供的类的class来获取这个类中的所有信息 包括属性 方法等
~~~



216、程序、进程、线程各有什么区别

~~~
程序：是计算机指令的集合，以文件的形式存储在磁盘上。

进程:是一个程序在其 自身的地址空间中的一次执行活动。资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源，而程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占系统的运行资源。

线程：进程中的一个单一的连续控制流程。一个进程可以拥有多个线程。
线程又称轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度，区别在于线程没有独立的存储空间，而是和所属进程中的其它线程共享一个存储空间，这使得线程间的通信远较进程简单。
~~~



217、字节流、字符流、缓冲流、随机流各有什么意义

~~~
字节流可以传输文件 字符流只能传输文本 缓冲流可以加快传输速度
~~~



218、ip、端口、dns、cdn、lvs是什么

~~~
cdn 内容分发网络
lvs 负载均衡
~~~



219、docker是干什么的

~~~
docker是可以安装各个服务的容器
~~~



220、对象的上转型

~~~
（Object）obj
~~~



221、解释重写、重载

222、高内聚低耦合

223、开闭原则

224、笛卡尔乘积、水平切割、垂直切割

225、oracle当中5个组函数

~~~
max,min,count,sum,avg
~~~



226、oracle当中五大约束

~~~
主键，外键，非空，检查，唯一
~~~



227、ddl/dcl/dml/dql/orm

228、sql当中单行函数取整、四舍五入、截断各是哪些函数

~~~
floor ceil round trunc
~~~



229、子查询和表连接，那个效率高

~~~
子查询会导致索引失效 数据库会默认查全表
~~~



230、如何进行数据库优化

~~~
读写分离 主从同步
~~~



231、jdk当中栈内存、堆内存、常量区的区别

~~~

~~~



232、页面有哪些可以向后台发起请求的标签

233、css是什么，js是什么，jquery是什么，nodejs是什么，vue是什么

234、js调试、css“调试“怎么操作

235、前端有哪些选择器js/css236、jsp内置对象

237、jsp四大作用域

238、java编程规范

239、javabean

240、servlet几种实现

241、mvc是啥

242、服务器端跳转和客户端跳转

243、自定义过滤器注意什么

244、自定义标签怎么弄

245、jsp与html的区别

246、xml/html/gml的区别

247、dtd与schema的区别

248、load-on-startup作用

249、init-param与context-param的区别

250、jsp三大指令

251、列举jsp当中的6个动作

252、html乱码、jsp乱码、servlet接受参数乱码、数据库乱码怎么处理